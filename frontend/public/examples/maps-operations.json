{
  "id": "maps-operations",
  "title": "Maps e Opera√ß√µes",
  "description": "Dicion√°rios chave-valor e suas opera√ß√µes",
  "category": "B√°sicos",
  "tags": ["maps", "dicion√°rio", "chave-valor", "make", "delete"],
  "instruction": "# Maps em Go\n\n## O que s√£o Maps?\n\nMaps s√£o **dicion√°rios** que armazenam pares chave-valor. S√£o como HashMap em Java ou dictionaries em Python.\n\n```go\nvar idades map[string]int\nidades = make(map[string]int)\n```\n\n## Por que usar Maps?\n\n‚úÖ **Busca r√°pida**: O(1) tempo m√©dio\n‚úÖ **Chave √∫nica**: Cada chave aparece uma vez\n‚úÖ **Flexibilidade**: Qualquer tipo compar√°vel como chave\n‚úÖ **Din√¢mico**: Cresce e diminui conforme necess√°rio\n\n## 1. Criando Maps\n\n### Com `make()`\n```go\nidades := make(map[string]int)\nidades[\"Ana\"] = 25\nidades[\"Jo√£o\"] = 30\n```\n\n### Literal\n```go\nidades := map[string]int{\n    \"Ana\": 25,\n    \"Jo√£o\": 30,\n    \"Maria\": 28,\n}\n```\n\n### Map Vazio\n```go\nvar m map[string]int  // nil map\nm = map[string]int{}  // map vazio (n√£o nil)\n```\n\n## 2. Opera√ß√µes B√°sicas\n\n### Adicionar/Atualizar\n```go\nm[\"chave\"] = valor\n```\n\n### Ler\n```go\nvalor := m[\"chave\"]  // 0 se chave n√£o existe\n```\n\n### Ler com Verifica√ß√£o\n```go\nvalor, existe := m[\"chave\"]\nif existe {\n    // chave existe\n}\n```\n\n### Deletar\n```go\ndelete(m, \"chave\")\n```\n\n### Tamanho\n```go\ntamanho := len(m)\n```\n\n## 3. Zero Value\n\n‚ö†Ô∏è **Map nil**: N√£o pode ser escrito!\n\n```go\nvar m map[string]int  // nil\n// m[\"key\"] = 1        // PANIC!\n\nm = make(map[string]int)  // Agora funciona\nm[\"key\"] = 1\n```\n\n## 4. Tipos de Chaves\n\n### Tipos Compar√°veis (podem ser chaves)\n- `string`, `int`, `float64`, `bool`\n- Arrays (se elementos s√£o compar√°veis)\n- Structs (se todos os campos s√£o compar√°veis)\n\n### N√£o Compar√°veis (N√ÉO podem ser chaves)\n- Slices: `[]int`\n- Maps: `map[string]int`\n- Functions\n\n```go\n// ‚úÖ V√°lidos\nm1 := make(map[string]int)\nm2 := make(map[int]string)\nm3 := make(map[[3]int]bool)  // array como chave\n\n// ‚ùå Inv√°lidos\n// m4 := make(map[[]int]string)     // slice\n// m5 := make(map[map[string]int]int) // map\n```\n\n## 5. Iterando Maps\n\n### Range\n```go\nfor chave, valor := range m {\n    fmt.Printf(\"%s: %d\\n\", chave, valor)\n}\n```\n\n### Apenas Chaves\n```go\nfor chave := range m {\n    fmt.Println(chave)\n}\n```\n\n### Apenas Valores\n```go\nfor _, valor := range m {\n    fmt.Println(valor)\n}\n```\n\n‚ö†Ô∏è **Ordem**: Maps n√£o garantem ordem de itera√ß√£o!\n\n## 6. Maps como Referencias\n\nMaps s√£o **tipos de refer√™ncia**:\n\n```go\noriginal := map[string]int{\"a\": 1}\ncopia := original\ncopia[\"a\"] = 2\n// original[\"a\"] agora √© 2 tamb√©m!\n```\n\n## 7. Maps Aninhados\n\n```go\n// Map de maps\nusuarios := map[string]map[string]interface{}{\n    \"user1\": {\n        \"nome\": \"Ana\",\n        \"idade\": 25,\n        \"ativo\": true,\n    },\n}\n```\n\n## 8. Padr√µes Comuns\n\n### Contador\n```go\ncontador := make(map[string]int)\nfor _, palavra := range palavras {\n    contador[palavra]++  // Incrementa (0 + 1 se n√£o existe)\n}\n```\n\n### Set (Conjunto)\n```go\nset := make(map[string]bool)\nset[\"item1\"] = true\nset[\"item2\"] = true\n\n// Verificar se existe\nif set[\"item1\"] {\n    // item existe no set\n}\n```\n\n### Lookup Table\n```go\nstatusCode := map[int]string{\n    200: \"OK\",\n    404: \"Not Found\",\n    500: \"Internal Error\",\n}\n```\n\n## 9. Performance\n\n- **Busca**: O(1) tempo m√©dio\n- **Inser√ß√£o**: O(1) tempo m√©dio\n- **Dele√ß√£o**: O(1) tempo m√©dio\n- **Hash Function**: Go usa hash eficiente internamente\n\n## Boas Pr√°ticas\n\n‚úÖ **Inicialize** antes de usar (`make()` ou literal)\n‚úÖ **Verifique exist√™ncia** com comma ok idiom\n‚úÖ **Use tipos simples** como chaves quando poss√≠vel\n‚úÖ **Delete** entradas desnecess√°rias para liberar mem√≥ria\n‚ùå **N√£o assuma** ordem de itera√ß√£o\n‚ùå **N√£o use** tipos n√£o-compar√°veis como chaves\n\n## Maps vs Slices\n\n| Maps | Slices |\n|------|--------|\n| Chave-valor | Indexado por posi√ß√£o |\n| Acesso O(1) | Acesso O(1) por √≠ndice |\n| Desordenado | Ordenado |\n| Chaves √∫nicas | Valores podem repetir |\n| Refer√™ncia | Refer√™ncia (para array) |\n\n## Quando Usar Maps\n\n‚úÖ **Lookup r√°pido** por chave\n‚úÖ **Chaves √∫nicas** (como IDs)\n‚úÖ **Contadores** e **agrega√ß√µes**\n‚úÖ **Cache** e **memoiza√ß√£o**\n‚úÖ **Configura√ß√µes** chave-valor\n\n## Experimente\n\n- Crie maps com diferentes tipos de chaves\n- Teste a diferen√ßa entre nil map e map vazio\n- Use range para iterar e ver que ordem varia\n- Implemente contadores e sets\n- Crie lookup tables para seus dados\n\n---\n*üí° Dica: Maps s√£o perfeitos quando voc√™ precisa de acesso r√°pido por chave!*",
  "code": "package main\n\nimport (\n    \"fmt\"\n    \"sort\"\n    \"strings\"\n)\n\nfunc main() {\n    fmt.Println(\"=== MAPS EM GO ===\\n\")\n    \n    // 1. CRIANDO MAPS\n    fmt.Println(\"üóÇÔ∏è CRIANDO MAPS:\")\n    \n    // Com make()\n    idades := make(map[string]int)\n    idades[\"Ana\"] = 25\n    idades[\"Jo√£o\"] = 30\n    idades[\"Maria\"] = 28\n    \n    fmt.Printf(\"Idades (make): %v\\n\", idades)\n    \n    // Map literal\n    paises := map[string]string{\n        \"BR\": \"Brasil\",\n        \"US\": \"Estados Unidos\",\n        \"JP\": \"Jap√£o\",\n        \"DE\": \"Alemanha\",\n    }\n    \n    fmt.Printf(\"Pa√≠ses: %v\\n\", paises)\n    \n    // Map de diferentes tipos\n    config := map[string]interface{}{\n        \"host\": \"localhost\",\n        \"port\": 8080,\n        \"debug\": true,\n        \"timeout\": 30.5,\n    }\n    \n    fmt.Printf(\"Config: %v\\n\\n\", config)\n    \n    // 2. OPERA√á√ïES B√ÅSICAS\n    fmt.Println(\"üîß OPERA√á√ïES B√ÅSICAS:\")\n    \n    // Lendo valores\n    fmt.Printf(\"Idade da Ana: %d\\n\", idades[\"Ana\"])\n    fmt.Printf(\"Idade inexistente: %d (zero value)\\n\", idades[\"Pedro\"])\n    \n    // Lendo com verifica√ß√£o (comma ok idiom)\n    if idade, existe := idades[\"Maria\"]; existe {\n        fmt.Printf(\"‚úÖ Maria tem %d anos\\n\", idade)\n    }\n    \n    if _, existe := idades[\"Pedro\"]; !existe {\n        fmt.Println(\"‚ùå Pedro n√£o est√° no mapa\")\n    }\n    \n    // Adicionando/atualizando\n    idades[\"Pedro\"] = 35\n    idades[\"Ana\"] = 26  // Atualizando\n    \n    fmt.Printf(\"Ap√≥s adi√ß√µes: %v\\n\", idades)\n    fmt.Printf(\"Tamanho do map: %d\\n\\n\", len(idades))\n    \n    // 3. DELETANDO\n    fmt.Println(\"üóëÔ∏è DELETANDO ELEMENTOS:\")\n    \n    fmt.Printf(\"Antes de deletar: %v\\n\", idades)\n    \n    delete(idades, \"Jo√£o\")\n    fmt.Printf(\"Ap√≥s deletar Jo√£o: %v\\n\", idades)\n    \n    // Delete de chave inexistente √© seguro\n    delete(idades, \"ChaveInexistente\")\n    fmt.Println(\"Delete de chave inexistente: OK (sem erro)\\n\")\n    \n    // 4. ITERANDO MAPS\n    fmt.Println(\"üîÑ ITERANDO MAPS:\")\n    \n    fmt.Println(\"Chaves e valores:\")\n    for nome, idade := range idades {\n        fmt.Printf(\"  %s: %d anos\\n\", nome, idade)\n    }\n    \n    fmt.Println(\"\\nApenas chaves:\")\n    for nome := range idades {\n        fmt.Printf(\"  %s\\n\", nome)\n    }\n    \n    fmt.Println(\"\\nApenas valores:\")\n    for _, idade := range idades {\n        fmt.Printf(\"  %d\\n\", idade)\n    }\n    \n    fmt.Println(\"\\n‚ö†Ô∏è Maps n√£o garantem ordem - execute v√°rias vezes e veja!\")\n    \n    // 5. MAPS COM DIFERENTES TIPOS DE CHAVE\n    fmt.Println(\"\\nüîë DIFERENTES TIPOS DE CHAVE:\")\n    \n    // Int como chave\n    notas := map[int]string{\n        10: \"Excelente\",\n        8:  \"Bom\",\n        6:  \"Regular\",\n        4:  \"Ruim\",\n    }\n    fmt.Printf(\"Notas: %v\\n\", notas)\n    \n    // Bool como chave\n    status := map[bool]string{\n        true:  \"Ativo\",\n        false: \"Inativo\",\n    }\n    fmt.Printf(\"Status: %v\\n\", status)\n    \n    // Array como chave (arrays s√£o compar√°veis)\n    coordenadas := map[[2]int]string{\n        [2]int{0, 0}: \"Origem\",\n        [2]int{1, 1}: \"Diagonal\",\n        [2]int{0, 1}: \"Norte\",\n    }\n    fmt.Printf(\"Coordenadas: %v\\n\\n\", coordenadas)\n    \n    // 6. PADR√ïES COMUNS\n    fmt.Println(\"üìä PADR√ïES COMUNS:\")\n    \n    // Contador de palavras\n    texto := \"go √© uma linguagem go √© fant√°stica go rocks\"\n    palavras := strings.Fields(texto)\n    \n    contador := make(map[string]int)\n    for _, palavra := range palavras {\n        contador[palavra]++  // Se n√£o existe, come√ßa com 0 e incrementa\n    }\n    \n    fmt.Printf(\"Texto: \"%s\"\\n\", texto)\n    fmt.Println(\"Contador de palavras:\")\n    for palavra, count := range contador {\n        fmt.Printf(\"  '%s': %d vezes\\n\", palavra, count)\n    }\n    \n    // Set (conjunto) usando map[string]bool\n    fmt.Println(\"\\nüìã SET (usando map[string]bool):\")\n    \n    linguagens := []string{\"Go\", \"Python\", \"Java\", \"Go\", \"JavaScript\", \"Python\"}\n    set := make(map[string]bool)\n    \n    for _, lang := range linguagens {\n        set[lang] = true\n    }\n    \n    fmt.Printf(\"Linguagens originais: %v\\n\", linguagens)\n    fmt.Print(\"Linguagens √∫nicas: \")\n    for lang := range set {\n        fmt.Printf(\"%s \", lang)\n    }\n    fmt.Println()\n    \n    // Verificando se item existe no set\n    if set[\"Go\"] {\n        fmt.Println(\"‚úÖ Go est√° no set\")\n    }\n    \n    if !set[\"Rust\"] {\n        fmt.Println(\"‚ùå Rust n√£o est√° no set\")\n    }\n    \n    // 7. LOOKUP TABLE\n    fmt.Println(\"\\nüîç LOOKUP TABLE:\")\n    \n    codigosHTTP := map[int]string{\n        200: \"OK\",\n        201: \"Created\",\n        400: \"Bad Request\",\n        401: \"Unauthorized\",\n        404: \"Not Found\",\n        500: \"Internal Server Error\",\n    }\n    \n    codigos := []int{200, 404, 500, 999}\n    \n    for _, codigo := range codigos {\n        if descricao, existe := codigosHTTP[codigo]; existe {\n            fmt.Printf(\"‚úÖ %d: %s\\n\", codigo, descricao)\n        } else {\n            fmt.Printf(\"‚ùå %d: C√≥digo desconhecido\\n\", codigo)\n        }\n    }\n    \n    // 8. MAP DE STRUCTS\n    fmt.Println(\"\\nüë• MAP DE STRUCTS:\")\n    \n    type Pessoa struct {\n        Nome     string\n        Idade    int\n        Profissao string\n    }\n    \n    pessoas := map[string]Pessoa{\n        \"001\": {\"Ana Silva\", 28, \"Desenvolvedora\"},\n        \"002\": {\"Jo√£o Santos\", 35, \"Designer\"},\n        \"003\": {\"Maria Costa\", 42, \"Gerente\"},\n    }\n    \n    fmt.Println(\"Banco de dados de pessoas:\")\n    for id, pessoa := range pessoas {\n        fmt.Printf(\"  ID %s: %s (%d anos) - %s\\n\", \n            id, pessoa.Nome, pessoa.Idade, pessoa.Profissao)\n    }\n    \n    // 9. MAP ANINHADO\n    fmt.Println(\"\\nüè¢ MAP ANINHADO:\")\n    \n    empresa := map[string]map[string]interface{}{\n        \"funcionario1\": {\n            \"nome\": \"Carlos\",\n            \"salario\": 5000.0,\n            \"ativo\": true,\n        },\n        \"funcionario2\": {\n            \"nome\": \"Lucia\",\n            \"salario\": 6500.0,\n            \"ativo\": false,\n        },\n    }\n    \n    for id, dados := range empresa {\n        fmt.Printf(\"ID: %s\\n\", id)\n        for chave, valor := range dados {\n            fmt.Printf(\"  %s: %v\\n\", chave, valor)\n        }\n        fmt.Println()\n    }\n    \n    // 10. FUN√á√ïES AUXILIARES\n    fmt.Println(\"üõ†Ô∏è FUN√á√ïES AUXILIARES:\")\n    \n    cores := map[string]string{\n        \"vermelho\": \"#FF0000\",\n        \"verde\": \"#00FF00\",\n        \"azul\": \"#0000FF\",\n    }\n    \n    fmt.Printf(\"Cores dispon√≠veis: %v\\n\", obterChaves(cores))\n    fmt.Printf(\"C√≥digos hex: %v\\n\", obterValores(cores))\n    fmt.Printf(\"Tem cor azul? %t\\n\", contemChave(cores, \"azul\"))\n    fmt.Printf(\"Tem cor rosa? %t\\n\", contemChave(cores, \"rosa\"))\n    \n    // Copiando map\n    coresCopia := copiarMap(cores)\n    coresCopia[\"amarelo\"] = \"#FFFF00\"\n    \n    fmt.Printf(\"Original: %v\\n\", cores)\n    fmt.Printf(\"C√≥pia modificada: %v\\n\", coresCopia)\n    \n    // 11. NIL MAP vs MAP VAZIO\n    fmt.Println(\"\\n‚ö†Ô∏è NIL MAP vs MAP VAZIO:\")\n    \n    var mapNil map[string]int\n    mapVazio := map[string]int{}\n    mapComMake := make(map[string]int)\n    \n    fmt.Printf(\"Nil map == nil: %t\\n\", mapNil == nil)\n    fmt.Printf(\"Map vazio == nil: %t\\n\", mapVazio == nil)\n    fmt.Printf(\"Map com make == nil: %t\\n\", mapComMake == nil)\n    \n    // Pode ler de nil map\n    fmt.Printf(\"Lendo de nil map: %d\\n\", mapNil[\"key\"])\n    \n    // Mas n√£o pode escrever!\n    // mapNil[\"key\"] = 1  // Isso causaria PANIC!\n    \n    // Maps vazios podem ser escritos\n    mapVazio[\"key\"] = 1\n    mapComMake[\"key\"] = 1\n    \n    fmt.Printf(\"Map vazio ap√≥s escrita: %v\\n\", mapVazio)\n    fmt.Printf(\"Map com make ap√≥s escrita: %v\\n\", mapComMake)\n    \n    fmt.Println(\"\\n=== RESUMO ===\\n\")\n    fmt.Println(\"‚úÖ Maps s√£o dicion√°rios chave-valor\")\n    fmt.Println(\"‚úÖ Busca, inser√ß√£o e dele√ß√£o O(1)\")\n    fmt.Println(\"‚úÖ Chaves devem ser tipos compar√°veis\")\n    fmt.Println(\"‚úÖ Use comma ok para verificar exist√™ncia\")\n    fmt.Println(\"‚úÖ delete() remove elementos\")\n    fmt.Println(\"‚úÖ Itera√ß√£o com range (ordem n√£o garantida)\")\n    fmt.Println(\"‚ö†Ô∏è Maps s√£o referencias - cuidado ao copiar\")\n    fmt.Println(\"‚ö†Ô∏è Nil maps n√£o podem ser escritos\")\n}\n\n// Fun√ß√£o que retorna todas as chaves de um map\nfunc obterChaves(m map[string]string) []string {\n    chaves := make([]string, 0, len(m))\n    for chave := range m {\n        chaves = append(chaves, chave)\n    }\n    sort.Strings(chaves) // Ordenar para sa√≠da consistente\n    return chaves\n}\n\n// Fun√ß√£o que retorna todos os valores de um map\nfunc obterValores(m map[string]string) []string {\n    valores := make([]string, 0, len(m))\n    for _, valor := range m {\n        valores = append(valores, valor)\n    }\n    return valores\n}\n\n// Fun√ß√£o que verifica se uma chave existe\nfunc contemChave(m map[string]string, chave string) bool {\n    _, existe := m[chave]\n    return existe\n}\n\n// Fun√ß√£o que copia um map\nfunc copiarMap(original map[string]string) map[string]string {\n    copia := make(map[string]string)\n    for chave, valor := range original {\n        copia[chave] = valor\n    }\n    return copia\n}\n"
}