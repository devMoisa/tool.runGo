{
  "id": "strings-text",
  "title": "Strings e Texto",
  "description": "Manipula√ß√£o de strings, runes e texto em Go",
  "category": "B√°sicos",
  "tags": ["strings", "runes", "unicode", "texto", "formata√ß√£o"],
  "instruction": "# Strings e Texto em Go\n\n## Strings em Go s√£o Especiais\n\nStrings em Go s√£o **imut√°veis** e **UTF-8** por padr√£o. Isso significa suporte nativo para emojis, acentos e caracteres internacionais!\n\n```go\ns := \"Ol√°, ‰∏ñÁïå! üåç\"\nfmt.Println(s)  // Funciona perfeitamente\n```\n\n## 1. Caracter√≠sticas das Strings\n\n‚úÖ **Imut√°veis**: N√£o podem ser modificadas ap√≥s cria√ß√£o\n‚úÖ **UTF-8**: Suporte unicode nativo\n‚úÖ **Slice de bytes**: Internamente s√£o `[]byte`\n‚úÖ **Zero value**: String vazia `\"\"`\n\n## 2. Declara√ß√£o e Inicializa√ß√£o\n\n### Formas B√°sicas\n```go\nvar nome string = \"Ana\"\nsobrenome := \"Silva\"\nvazio := \"\"  // String vazia\n```\n\n### Raw Strings (crase)\n```go\ncaminho := `C:\\\\Users\\\\Ana\\\\Documents`  // Sem escape\nsql := `\n    SELECT *\n    FROM usuarios\n    WHERE ativo = true\n`\n```\n\n### String Multilinhas\n```go\npoema := `Roses are red,\nViolets are blue,\nGo is awesome,\nAnd so are you!`\n```\n\n## 3. Runes vs Bytes\n\n### Bytes (uint8)\n- Cada posi√ß√£o na string\n- `len(s)` retorna n√∫mero de **bytes**\n\n### Runes (int32)\n- Representam **caracteres Unicode**\n- Um caractere pode usar m√∫ltiplos bytes\n\n```go\ns := \"Ol√°\"\nfmt.Printf(\"Bytes: %d\\n\", len(s))                    // 4 bytes\nfmt.Printf(\"Runes: %d\\n\", utf8.RuneCountInString(s)) // 3 caracteres\n```\n\n## 4. Itera√ß√£o\n\n### Por Bytes\n```go\nfor i := 0; i < len(s); i++ {\n    fmt.Printf(\"%c \", s[i])  // Pode quebrar com unicode\n}\n```\n\n### Por Runes (Recomendado)\n```go\nfor _, rune := range s {\n    fmt.Printf(\"%c \", rune)  // Funciona com unicode\n}\n```\n\n### Com √çndice\n```go\nfor i, rune := range s {\n    fmt.Printf(\"Posi√ß√£o %d: %c\\n\", i, rune)\n}\n```\n\n## 5. Package `strings`\n\n### Opera√ß√µes Comuns\n```go\nimport \"strings\"\n\n// Case\nstrings.ToUpper(\"hello\")     // \"HELLO\"\nstrings.ToLower(\"WORLD\")     // \"world\"\nstrings.Title(\"hello world\") // \"Hello World\"\n\n// Busca\nstrings.Contains(\"hello\", \"ell\")  // true\nstrings.Index(\"hello\", \"ll\")     // 2\nstrings.Count(\"hello\", \"l\")      // 2\n\n// Modifica√ß√£o\nstrings.Replace(\"hello\", \"l\", \"x\", -1)  // \"hexxo\"\nstrings.Trim(\"  hello  \", \" \")        // \"hello\"\nstrings.Split(\"a,b,c\", \",\")           // [\"a\", \"b\", \"c\"]\nstrings.Join([\"a\", \"b\"], \"-\")      // \"a-b\"\n```\n\n## 6. Formata√ß√£o com `fmt`\n\n### Printf Verbs\n```go\nnome := \"Ana\"\nidade := 25\npreco := 19.99\n\nfmt.Printf(\"Nome: %s\\n\", nome)           // String\nfmt.Printf(\"Idade: %d anos\\n\", idade)     // Inteiro\nfmt.Printf(\"Pre√ßo: %.2f\\n\", preco)       // Float com 2 decimais\nfmt.Printf(\"Hex: %x\\n\", 255)            // Hexadecimal\nfmt.Printf(\"Bin√°rio: %b\\n\", 8)          // Bin√°rio\n```\n\n### Sprintf (String Formatada)\n```go\nmensagem := fmt.Sprintf(\"%s tem %d anos\", nome, idade)\n```\n\n## 7. Strings Builder\n\nPara **constru√ß√£o eficiente** de strings:\n\n```go\nvar builder strings.Builder\n\nbuilder.WriteString(\"Hello\")\nbuilder.WriteString(\" \")\nbuilder.WriteString(\"World\")\n\nresultado := builder.String()  // \"Hello World\"\n```\n\nüí° **Por que usar Builder?**\n- Strings s√£o imut√°veis\n- Concatena√ß√£o com `+` cria novas strings\n- Builder √© mais eficiente para muitas opera√ß√µes\n\n## 8. Convers√µes\n\n### String ‚Üî Slice de Bytes\n```go\ns := \"hello\"\nbytes := []byte(s)      // String para []byte\nback := string(bytes)   // []byte para string\n```\n\n### String ‚Üî N√∫meros\n```go\nimport \"strconv\"\n\n// String para n√∫mero\nnum, err := strconv.Atoi(\"123\")        // int\nfloat, err := strconv.ParseFloat(\"3.14\", 64)\n\n// N√∫mero para string\nstr := strconv.Itoa(123)               // int para string\nstr = strconv.FormatFloat(3.14, 'f', 2, 64)\n```\n\n## 9. Regex (Express√µes Regulares)\n\n```go\nimport \"regexp\"\n\n// Compilar regex\nre := regexp.MustCompile(`\\\\d+`)  // N√∫meros\n\n// Buscar\nmatches := re.FindAllString(\"abc123def456\", -1)  // [\"123\", \"456\"]\n\n// Substituir\nresult := re.ReplaceAllString(\"abc123\", \"XXX\")  // \"abcXXX\"\n```\n\n## 10. Unicode e Internacionaliza√ß√£o\n\n```go\nimport \"unicode/utf8\"\n\ns := \"Hello, ‰∏ñÁïå! üåç\"\n\nfmt.Printf(\"Bytes: %d\\n\", len(s))\nfmt.Printf(\"Runes: %d\\n\", utf8.RuneCountInString(s))\n\n// Verificar se √© UTF-8 v√°lido\nfmt.Printf(\"UTF-8 v√°lido: %t\\n\", utf8.ValidString(s))\n```\n\n## Boas Pr√°ticas\n\n‚úÖ **Use range** para iterar strings com unicode\n‚úÖ **strings.Builder** para concatena√ß√£o m√∫ltipla\n‚úÖ **Raw strings** para paths e regex\n‚úÖ **strconv** para convers√µes num√©ricas\n‚úÖ **Teste com caracteres n√£o-ASCII**\n‚ùå **Evite** concatena√ß√£o com `+` em loops\n‚ùå **N√£o modifique** bytes de string diretamente\n\n## Performance\n\n| Opera√ß√£o | M√©todo | Performance |\n|----------|--------|-------------|\n| 1-2 concatena√ß√µes | `+` | Boa |\n| Muitas concatena√ß√µes | `strings.Builder` | Melhor |\n| Busca simples | `strings.Contains` | Boa |\n| Busca complexa | `regexp` | Mais lenta |\n\n## Padr√µes Comuns\n\n### Valida√ß√£o\n```go\nfunc validarEmail(email string) bool {\n    return strings.Contains(email, \"@\") && \n           strings.Contains(email, \".\")\n}\n```\n\n### Sanitiza√ß√£o\n```go\nfunc limparInput(input string) string {\n    input = strings.TrimSpace(input)\n    input = strings.ToLower(input)\n    return input\n}\n```\n\n### Template Simples\n```go\nfunc template(nome, sobrenome string) string {\n    return fmt.Sprintf(\"Ol√°, %s %s! Bem-vindo!\", nome, sobrenome)\n}\n```\n\n## Experimente\n\n- Teste strings com emojis e acentos\n- Compare itera√ß√£o por bytes vs runes\n- Use strings.Builder para construir texto grande\n- Experimente diferentes formata√ß√µes com Printf\n- Teste convers√µes entre strings e n√∫meros\n- Crie suas pr√≥prias fun√ß√µes de manipula√ß√£o\n\n---\n*üí° Dica: Go tem excelente suporte Unicode - abuse dos emojis! üöÄ*",
  "code": "package main\n\nimport (\n    \"fmt\"\n    \"regexp\"\n    \"strconv\"\n    \"strings\"\n    \"unicode/utf8\"\n)\n\nfunc main() {\n    fmt.Println(\"=== STRINGS E TEXTO ===\\n\")\n    \n    // 1. DECLARA√á√ÉO E TIPOS\n    fmt.Println(\"üìù DECLARA√á√ÉO E TIPOS:\")\n    \n    // Strings b√°sicas\n    nome := \"Ana Silva\"\n    empresa := \"BrolinGo Software\"\n    vazio := \"\"\n    \n    fmt.Printf(\"Nome: '%s'\\n\", nome)\n    fmt.Printf(\"Empresa: '%s'\\n\", empresa)\n    fmt.Printf(\"String vazia: '%s' (length: %d)\\n\", vazio, len(vazio))\n    \n    // Raw strings (com crase)\n    caminho := `C:\\\\Users\\\\Ana\\\\Documents\\\\projeto.txt`\n    sql := `\n        SELECT nome, idade\n        FROM usuarios\n        WHERE ativo = true\n        ORDER BY nome\n    `\n    \n    fmt.Printf(\"\\nCaminho (raw string): %s\\n\", caminho)\n    fmt.Printf(\"SQL (raw string): %s\\n\", sql)\n    \n    // 2. UNICODE E RUNES\n    fmt.Println(\"\\nüåç UNICODE E RUNES:\")\n    \n    textoUnicode := \"Ol√°, ‰∏ñÁïå! üåç Caf√© com a√ß√∫car\"\n    \n    fmt.Printf(\"Texto: %s\\n\", textoUnicode)\n    fmt.Printf(\"Bytes (len): %d\\n\", len(textoUnicode))\n    fmt.Printf(\"Runes (caracteres): %d\\n\", utf8.RuneCountInString(textoUnicode))\n    fmt.Printf(\"UTF-8 v√°lido: %t\\n\", utf8.ValidString(textoUnicode))\n    \n    // Itera√ß√£o por runes vs bytes\n    fmt.Println(\"\\nüîÑ ITERA√á√ÉO POR RUNES:\")\n    for i, r := range \"Ol√°üåç\" {\n        fmt.Printf(\"  Posi√ß√£o %d: %c (Unicode: U+%04X)\\n\", i, r, r)\n    }\n    \n    // 3. PACKAGE STRINGS\n    fmt.Println(\"\\nüõ†Ô∏è OPERA√á√ïES COM STRINGS:\")\n    \n    texto := \"  Hello World Programming in Go  \"\n    fmt.Printf(\"Original: '%s'\\n\", texto)\n    \n    // Case operations\n    fmt.Printf(\"Mai√∫sculo: '%s'\\n\", strings.ToUpper(texto))\n    fmt.Printf(\"Min√∫sculo: '%s'\\n\", strings.ToLower(texto))\n    fmt.Printf(\"Title: '%s'\\n\", strings.Title(strings.ToLower(texto)))\n    \n    // Trim operations\n    fmt.Printf(\"Trim espa√ßos: '%s'\\n\", strings.TrimSpace(texto))\n    fmt.Printf(\"Trim 'H' e 'o': '%s'\\n\", strings.Trim(texto, \" Ho\"))\n    \n    // Search operations\n    fmt.Printf(\"\\nüîç BUSCA E VERIFICA√á√ÉO:\\n\")\n    fmt.Printf(\"Cont√©m 'World': %t\\n\", strings.Contains(texto, \"World\"))\n    fmt.Printf(\"Cont√©m 'world': %t\\n\", strings.Contains(texto, \"world\"))\n    fmt.Printf(\"√çndice de 'World': %d\\n\", strings.Index(texto, \"World\"))\n    fmt.Printf(\"Conta 'o': %d\\n\", strings.Count(texto, \"o\"))\n    fmt.Printf(\"Come√ßa com '  Hello': %t\\n\", strings.HasPrefix(texto, \"  Hello\"))\n    fmt.Printf(\"Termina com 'Go  ': %t\\n\", strings.HasSuffix(texto, \"Go  \"))\n    \n    // Replace and split\n    fmt.Printf(\"\\n‚úÇÔ∏è REPLACE E SPLIT:\\n\")\n    fmt.Printf(\"Replace 'o' ‚Üí 'X': '%s'\\n\", strings.Replace(texto, \"o\", \"X\", 2))\n    fmt.Printf(\"Replace all 'o' ‚Üí 'X': '%s'\\n\", strings.ReplaceAll(texto, \"o\", \"X\"))\n    \n    palavras := strings.Fields(strings.TrimSpace(texto))\n    fmt.Printf(\"Split em palavras: %v\\n\", palavras)\n    fmt.Printf(\"Join com '-': '%s'\\n\", strings.Join(palavras, \"-\"))\n    \n    // 4. FORMATA√á√ÉO COM FMT\n    fmt.Println(\"\\nüé® FORMATA√á√ÉO COM FMT:\")\n    \n    pessoa := \"Jo√£o\"\n    idade := 30\n    altura := 1.75\n    ativo := true\n    \n    // Diferentes tipos de formata√ß√£o\n    fmt.Printf(\"String: '%s'\\n\", pessoa)\n    fmt.Printf(\"Inteiro: %d\\n\", idade)\n    fmt.Printf(\"Float simples: %f\\n\", altura)\n    fmt.Printf(\"Float formatado: %.2f\\n\", altura)\n    fmt.Printf(\"Booleano: %t\\n\", ativo)\n    fmt.Printf(\"Hexadecimal: %x\\n\", 255)\n    fmt.Printf(\"Bin√°rio: %b\\n\", 8)\n    fmt.Printf(\"Tipo: %T\\n\", altura)\n    \n    // Sprintf para criar strings formatadas\n    perfil := fmt.Sprintf(\"%s tem %d anos, %.2fm de altura e est√° %t\",\n        pessoa, idade, altura, ativo)\n    fmt.Printf(\"Sprintf: %s\\n\", perfil)\n    \n    // 5. STRINGS BUILDER\n    fmt.Println(\"\\nüèóÔ∏è STRINGS BUILDER (eficiente):\")\n    \n    var builder strings.Builder\n    \n    // Construindo string eficientemente\n    linguagens := []string{\"Go\", \"Python\", \"JavaScript\", \"Rust\", \"TypeScript\"}\n    \n    builder.WriteString(\"Linguagens de programa√ß√£o:\\n\")\n    for i, lang := range linguagens {\n        builder.WriteString(fmt.Sprintf(\"%d. %s\\n\", i+1, lang))\n    }\n    builder.WriteString(\"Total: \")\n    builder.WriteString(strconv.Itoa(len(linguagens)))\n    builder.WriteString(\" linguagens\")\n    \n    resultado := builder.String()\n    fmt.Println(resultado)\n    \n    // Comparando performance (demonstrativo)\n    fmt.Println(\"\\n‚ö° DEMONSTRA√á√ÉO DE PERFORMANCE:\")\n    demonstrarConcatenacao()\n    \n    // 6. CONVERS√ïES\n    fmt.Println(\"\\nüîÑ CONVERS√ïES:\")\n    \n    // String para n√∫meros\n    numStr := \"123\"\n    floatStr := \"3.14159\"\n    boolStr := \"true\"\n    \n    if num, err := strconv.Atoi(numStr); err == nil {\n        fmt.Printf(\"'%s' ‚Üí %d (int)\\n\", numStr, num)\n    }\n    \n    if f, err := strconv.ParseFloat(floatStr, 64); err == nil {\n        fmt.Printf(\"'%s' ‚Üí %.5f (float64)\\n\", floatStr, f)\n    }\n    \n    if b, err := strconv.ParseBool(boolStr); err == nil {\n        fmt.Printf(\"'%s' ‚Üí %t (bool)\\n\", boolStr, b)\n    }\n    \n    // N√∫meros para string\n    fmt.Printf(\"%d ‚Üí '%s' (string)\\n\", 456, strconv.Itoa(456))\n    fmt.Printf(\"%.2f ‚Üí '%s' (string)\\n\", 2.718, strconv.FormatFloat(2.718, 'f', 2, 64))\n    fmt.Printf(\"%t ‚Üí '%s' (string)\\n\", false, strconv.FormatBool(false))\n    \n    // String ‚Üî []byte\n    original := \"Hello, ‰∏ñÁïå!\"\n    bytes := []byte(original)\n    volta := string(bytes)\n    \n    fmt.Printf(\"\\nString ‚Üí []byte ‚Üí String:\\n\")\n    fmt.Printf(\"Original: %s\\n\", original)\n    fmt.Printf(\"Bytes: %v\\n\", bytes)\n    fmt.Printf(\"De volta: %s\\n\", volta)\n    \n    // 7. REGEX (EXPRESS√ïES REGULARES)\n    fmt.Println(\"\\nüéØ REGEX (Express√µes Regulares):\")\n    \n    email := \"usuario@exemplo.com.br\"\n    telefone := \"Ligue para (11) 99999-8888 ou (21) 88888-7777\"\n    \n    // Validar email (regex simples)\n    emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$`)\n    fmt.Printf(\"Email '%s' √© v√°lido: %t\\n\", email, emailRegex.MatchString(email))\n    \n    // Extrair telefones\n    telefoneRegex := regexp.MustCompile(`\\\\(\\\\d{2}\\\\)\\\\s\\\\d{5}-\\\\d{4}`)\n    telefones := telefoneRegex.FindAllString(telefone, -1)\n    fmt.Printf(\"Telefones encontrados: %v\\n\", telefones)\n    \n    // Substituir n√∫meros por XXX\n    numeroRegex := regexp.MustCompile(`\\\\d+`)\n    textoSeguro := numeroRegex.ReplaceAllString(telefone, \"XXX\")\n    fmt.Printf(\"Texto com n√∫meros mascarados: %s\\n\", textoSeguro)\n    \n    // 8. FUN√á√ïES AUXILIARES CUSTOMIZADAS\n    fmt.Println(\"\\nüîß FUN√á√ïES AUXILIARES:\")\n    \n    exemplos := []string{\n        \"  usuario@email.com  \",\n        \"TEXTO EM MAI√öSCULA\",\n        \"texto,com,v√≠rgulas\",\n        \"RemoverEspa√ßosECaracteresEspeciais!\",\n    }\n    \n    for _, exemplo := range exemplos {\n        fmt.Printf(\"Original: '%s'\\n\", exemplo)\n        fmt.Printf(\"  Limpo: '%s'\\n\", limparTexto(exemplo))\n        fmt.Printf(\"  Slug: '%s'\\n\", criarSlug(exemplo))\n        fmt.Printf(\"  Palavras: %d\\n\", contarPalavras(exemplo))\n        fmt.Println()\n    }\n    \n    // 9. TEMPLATE SIMPLES\n    fmt.Println(\"üìÑ TEMPLATE SIMPLES:\")\n    \n    usuario := \"Ana Silva\"\n    produto := \"BrolinGo Pro\"\n    preco := 99.90\n    \n    email1 := criarEmailBemVindo(usuario)\n    email2 := criarEmailCompra(usuario, produto, preco)\n    \n    fmt.Println(email1)\n    fmt.Println()\n    fmt.Println(email2)\n    \n    fmt.Println(\"\\n=== RESUMO ===\\n\")\n    fmt.Println(\"‚úÖ Strings s√£o imut√°veis e UTF-8\")\n    fmt.Println(\"‚úÖ Use range para iterar com Unicode\")\n    fmt.Println(\"‚úÖ strings.Builder para concatena√ß√£o eficiente\")\n    fmt.Println(\"‚úÖ strconv para convers√µes num√©ricas\")\n    fmt.Println(\"‚úÖ regexp para padr√µes complexos\")\n    fmt.Println(\"‚úÖ fmt.Sprintf para formata√ß√£o\")\n    fmt.Println(\"üåç Go tem excelente suporte Unicode!\")\n}\n\n// Fun√ß√£o para demonstrar diferen√ßa de performance\nfunc demonstrarConcatenacao() {\n    // Simula√ß√£o simples - em aplica√ß√µes reais, use benchmarks\n    fmt.Println(\"Concatenando 1000 strings...\")\n    \n    // Com strings.Builder (eficiente)\n    var builder strings.Builder\n    for i := 0; i < 1000; i++ {\n        builder.WriteString(\"x\")\n    }\n    resultado1 := builder.String()\n    \n    // Com + (ineficiente para muitas opera√ß√µes)\n    resultado2 := \"\"\n    for i := 0; i < 100; i++ { // Menos opera√ß√µes para n√£o demorar\n        resultado2 += \"x\"\n    }\n    \n    fmt.Printf(\"Builder: %d caracteres\\n\", len(resultado1))\n    fmt.Printf(\"Concatena√ß√£o: %d caracteres\\n\", len(resultado2))\n    fmt.Println(\"üí° Para muitas opera√ß√µes, Builder √© mais eficiente!\")\n}\n\n// Fun√ß√£o para limpar texto\nfunc limparTexto(texto string) string {\n    // Remove espa√ßos do in√≠cio e fim\n    texto = strings.TrimSpace(texto)\n    // Converte para min√∫scula\n    texto = strings.ToLower(texto)\n    return texto\n}\n\n// Fun√ß√£o para criar slug (URL amig√°vel)\nfunc criarSlug(texto string) string {\n    // Limpa o texto\n    slug := limparTexto(texto)\n    // Remove caracteres especiais (regex simples)\n    reg := regexp.MustCompile(`[^a-z0-9\\\\s]`)\n    slug = reg.ReplaceAllString(slug, \"\")\n    // Substitui espa√ßos por h√≠fens\n    slug = strings.ReplaceAll(slug, \" \", \"-\")\n    // Remove h√≠fens m√∫ltiplos\n    slug = regexp.MustCompile(`-+`).ReplaceAllString(slug, \"-\")\n    // Remove h√≠fens do in√≠cio e fim\n    slug = strings.Trim(slug, \"-\")\n    return slug\n}\n\n// Fun√ß√£o para contar palavras\nfunc contarPalavras(texto string) int {\n    palavras := strings.Fields(strings.TrimSpace(texto))\n    return len(palavras)\n}\n\n// Template de email de boas-vindas\nfunc criarEmailBemVindo(nome string) string {\n    template := `Ol√°, %s!\n\nSeja bem-vindo(a) ao BrolinGo Software! üéâ\n\nEstamos muito felizes em t√™-lo(a) conosco.\n\nAtenciosamente,\nEquipe BrolinGo`\n    \n    return fmt.Sprintf(template, nome)\n}\n\n// Template de email de compra\nfunc criarEmailCompra(nome, produto string, preco float64) string {\n    template := `Ol√°, %s!\n\nObrigado pela sua compra! üõí\n\nDetalhes do pedido:\n‚Ä¢ Produto: %s\n‚Ä¢ Valor: R$ %.2f\n\nSeu produto ser√° enviado em breve.\n\nAtenciosamente,\nEquipe BrolinGo`\n    \n    return fmt.Sprintf(template, nome, produto, preco)\n}\n"
}