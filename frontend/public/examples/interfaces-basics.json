{
  "id": "interfaces-basics",
  "title": "Interfaces B√°sicas",
  "description": "Conceitos fundamentais de interfaces em Go",
  "category": "B√°sicos",
  "tags": ["interfaces", "polimorfismo", "duck typing", "implementa√ß√£o impl√≠cita"],
  "instruction": "# Interfaces em Go\n\n## O que s√£o Interfaces?\n\nInterfaces definem **comportamentos** (m√©todos) que tipos devem implementar. S√£o **contratos** que garantem que um tipo tenha determinados m√©todos.\n\n```go\ntype Falador interface {\n    Falar() string\n}\n```\n\n## Por que Interfaces s√£o Poderosas?\n\n‚úÖ **Polimorfismo**: Um tipo, m√∫ltiplas formas\n‚úÖ **Desacoplamento**: Dependa de comportamentos, n√£o implementa√ß√µes\n‚úÖ **Testabilidade**: Mock de depend√™ncias facilmente\n‚úÖ **Flexibilidade**: Adapte c√≥digo sem alterar tipos existentes\n\n## 1. Implementa√ß√£o Impl√≠cita\n\n**Go n√£o tem palavra-chave `implements`!** Se um tipo tem os m√©todos da interface, ele automaticamente a implementa.\n\n```go\ntype Gato struct {\n    Nome string\n}\n\n// Gato implementa Falador automaticamente\nfunc (g Gato) Falar() string {\n    return \"Miau!\"\n}\n```\n\n## 2. Duck Typing\n\n*\"Se anda como pato e fala como pato, ent√£o √© um pato\"*\n\n```go\n// Se tem m√©todo Falar(), √© um Falador\nfunc cumprimentar(f Falador) {\n    fmt.Println(f.Falar())\n}\n\ncumprimentar(Gato{\"Mimi\"})  // Funciona!\ncumprimentar(Cachorro{\"Rex\"})  // Tamb√©m funciona!\n```\n\n## 3. Interface Vazia\n\n`interface{}` aceita **qualquer tipo**:\n\n```go\nfunc imprimir(valor interface{}) {\n    fmt.Println(valor)\n}\n\nimprimir(42)        // int\nimprimir(\"hello\")   // string\nimprimir(true)      // bool\n```\n\n*Go 1.18+: Use `any` ao inv√©s de `interface{}`*\n\n## 4. Type Assertion\n\nExtraindo o tipo concreto de uma interface:\n\n```go\nfunc processar(valor interface{}) {\n    // Type assertion com verifica√ß√£o\n    if str, ok := valor.(string); ok {\n        fmt.Printf(\"String: %s\\n\", str)\n    }\n    \n    // Type assertion direta (pode dar panic)\n    numero := valor.(int)  // Panic se n√£o for int\n}\n```\n\n## 5. Type Switch\n\nVerificando m√∫ltiplos tipos:\n\n```go\nfunc identificarTipo(valor interface{}) {\n    switch v := valor.(type) {\n    case int:\n        fmt.Printf(\"Inteiro: %d\\n\", v)\n    case string:\n        fmt.Printf(\"String: %s\\n\", v)\n    case bool:\n        fmt.Printf(\"Booleano: %t\\n\", v)\n    default:\n        fmt.Printf(\"Tipo desconhecido: %T\\n\", v)\n    }\n}\n```\n\n## 6. Composi√ß√£o de Interfaces\n\n```go\ntype Leitor interface {\n    Ler() []byte\n}\n\ntype Escritor interface {\n    Escrever([]byte) error\n}\n\n// Interface composta\ntype LeitorEscritor interface {\n    Leitor\n    Escritor\n}\n```\n\n## 7. Interfaces Comuns da Standard Library\n\n### Stringer\n```go\ntype Stringer interface {\n    String() string\n}\n```\n\n### Error\n```go\ntype error interface {\n    Error() string\n}\n```\n\n### Reader/Writer\n```go\ntype Reader interface {\n    Read([]byte) (n int, err error)\n}\n```\n\n## Boas Pr√°ticas\n\n‚úÖ **Interfaces pequenas**: Prefira 1-2 m√©todos\n‚úÖ **Defina onde usa**: N√£o onde implementa\n‚úÖ **Nomes descritivos**: `Reader`, `Writer`, `Stringer`\n‚úÖ **Aceite interfaces, retorne structs**\n‚ùå **Evite** interfaces muito grandes\n‚ùå **N√£o crie** interfaces desnecess√°rias\n\n## Padr√µes Comuns\n\n### Strategy Pattern\n```go\ntype Processador interface {\n    Processar(dados []byte) []byte\n}\n\nfunc executar(p Processador, dados []byte) []byte {\n    return p.Processar(dados)\n}\n```\n\n### Dependency Injection\n```go\ntype Logger interface {\n    Log(mensagem string)\n}\n\ntype Servico struct {\n    logger Logger  // Depende da interface, n√£o implementa√ß√£o\n}\n```\n\n## Quando N√ÉO usar Interfaces\n\n‚ùå **Apenas um tipo** implementa\n‚ùå **Interface muito espec√≠fica** para um caso\n‚ùå **Premature abstraction** - implemente quando precisar\n\n## Interfaces vs Structs\n\n| Interfaces | Structs |\n|------------|----------|\n| Comportamento | Dados |\n| Contrato | Implementa√ß√£o |\n| Polimorfismo | Tipo concreto |\n| Flexibilidade | Performance |\n\n## Experimente\n\n- Crie seus pr√≥prios tipos que implementem interfaces\n- Teste type assertions com diferentes tipos\n- Use type switch para processar valores diferentes\n- Combine interfaces para criar contratos mais complexos\n- Implemente interfaces da standard library\n\n---\n*üí° Dica: \"Accept interfaces, return concrete types\" - Rob Pike*",
  "code": "package main\n\nimport (\n    \"fmt\"\n    \"math\"\n    \"strconv\"\n    \"strings\"\n)\n\n// Interface b√°sica - define comportamento\ntype Falador interface {\n    Falar() string\n}\n\n// Interface para formas geom√©tricas\ntype Forma interface {\n    Area() float64\n    Perimetro() float64\n}\n\n// Interface composta\ntype FormaComDescricao interface {\n    Forma  // Embedded interface\n    Descricao() string\n}\n\n// Tipos que implementam Falador\ntype Gato struct {\n    Nome string\n}\n\nfunc (g Gato) Falar() string {\n    return fmt.Sprintf(\"%s faz: Miau! üê±\", g.Nome)\n}\n\ntype Cachorro struct {\n    Nome string\n    Raca string\n}\n\nfunc (c Cachorro) Falar() string {\n    return fmt.Sprintf(\"%s (%s) faz: Au au! üê∂\", c.Nome, c.Raca)\n}\n\ntype Pessoa struct {\n    Nome  string\n    Idade int\n}\n\nfunc (p Pessoa) Falar() string {\n    return fmt.Sprintf(\"%s diz: Ol√°! Tenho %d anos üëã\", p.Nome, p.Idade)\n}\n\n// Implementando Stringer (interface da stdlib)\nfunc (p Pessoa) String() string {\n    return fmt.Sprintf(\"Pessoa{Nome: %s, Idade: %d}\", p.Nome, p.Idade)\n}\n\n// Tipos que implementam Forma\ntype Retangulo struct {\n    Largura, Altura float64\n}\n\nfunc (r Retangulo) Area() float64 {\n    return r.Largura * r.Altura\n}\n\nfunc (r Retangulo) Perimetro() float64 {\n    return 2 * (r.Largura + r.Altura)\n}\n\nfunc (r Retangulo) Descricao() string {\n    return fmt.Sprintf(\"Ret√¢ngulo %.1fx%.1f\", r.Largura, r.Altura)\n}\n\ntype Circulo struct {\n    Raio float64\n}\n\nfunc (c Circulo) Area() float64 {\n    return math.Pi * c.Raio * c.Raio\n}\n\nfunc (c Circulo) Perimetro() float64 {\n    return 2 * math.Pi * c.Raio\n}\n\nfunc (c Circulo) Descricao() string {\n    return fmt.Sprintf(\"C√≠rculo com raio %.1f\", c.Raio)\n}\n\n// Fun√ß√£o que aceita qualquer Falador\nfunc cumprimentar(f Falador) {\n    fmt.Printf(\"üëã %s\\n\", f.Falar())\n}\n\n// Fun√ß√£o que aceita qualquer Forma\nfunc calcularPropriedades(f Forma) {\n    fmt.Printf(\"üìê √Årea: %.2f, Per√≠metro: %.2f\\n\", f.Area(), f.Perimetro())\n    \n    // Type assertion para verificar se tamb√©m √© FormaComDescricao\n    if desc, ok := f.(FormaComDescricao); ok {\n        fmt.Printf(\"üìù %s\\n\", desc.Descricao())\n    }\n}\n\n// Fun√ß√£o que usa interface{} (any)\nfunc descreverTipo(valor interface{}) {\n    // Type switch\n    switch v := valor.(type) {\n    case int:\n        fmt.Printf(\"üî¢ N√∫mero inteiro: %d\\n\", v)\n    case float64:\n        fmt.Printf(\"üî¢ N√∫mero decimal: %.2f\\n\", v)\n    case string:\n        fmt.Printf(\"üìù Texto: \"%s\"\\n\", v)\n    case bool:\n        fmt.Printf(\"‚úÖ Booleano: %t\\n\", v)\n    case Pessoa:\n        fmt.Printf(\"üë§ %s\\n\", v)\n    case Falador:\n        fmt.Printf(\"üó£Ô∏è Algo que fala: %s\\n\", v.Falar())\n    default:\n        fmt.Printf(\"‚ùì Tipo desconhecido: %T\\n\", v)\n    }\n}\n\n// Interface para processamento - Strategy pattern\ntype Processador interface {\n    Processar(texto string) string\n}\n\ntype ProcessadorMaiuscula struct{}\n\nfunc (p ProcessadorMaiuscula) Processar(texto string) string {\n    return strings.ToUpper(texto)\n}\n\ntype ProcessadorMinuscula struct{}\n\nfunc (p ProcessadorMinuscula) Processar(texto string) string {\n    return strings.ToLower(texto)\n}\n\ntype ProcessadorInvertido struct{}\n\nfunc (p ProcessadorInvertido) Processar(texto string) string {\n    runes := []rune(texto)\n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return string(runes)\n}\n\n// Fun√ß√£o que usa Strategy pattern\nfunc processarTexto(processador Processador, texto string) {\n    resultado := processador.Processar(texto)\n    fmt.Printf(\"üìù \"%s\" ‚Üí \"%s\"\\n\", texto, resultado)\n}\n\n// Interface customizada que implementa error\ntype ErroPersonalizado struct {\n    Codigo   int\n    Mensagem string\n}\n\nfunc (e ErroPersonalizado) Error() string {\n    return fmt.Sprintf(\"Erro %d: %s\", e.Codigo, e.Mensagem)\n}\n\n// Fun√ß√£o que retorna error (interface)\nfunc dividirComErroCustom(a, b float64) (float64, error) {\n    if b == 0 {\n        return 0, ErroPersonalizado{\n            Codigo:   1001,\n            Mensagem: \"Divis√£o por zero n√£o permitida\",\n        }\n    }\n    return a / b, nil\n}\n\nfunc main() {\n    fmt.Println(\"=== INTERFACES EM GO ===\\n\")\n    \n    // 1. Implementa√ß√£o impl√≠cita\n    fmt.Println(\"üó£Ô∏è Diferentes tipos implementando Falador:\")\n    \n    gato := Gato{\"Mimi\"}\n    cachorro := Cachorro{\"Rex\", \"Golden Retriever\"}\n    pessoa := Pessoa{\"Ana\", 25}\n    \n    // Todos implementam Falador implicitamente\n    cumprimentar(gato)\n    cumprimentar(cachorro)\n    cumprimentar(pessoa)\n    \n    fmt.Println(\"\\nüìê Formas geom√©tricas:\")\n    \n    // 2. Interface Forma\n    retangulo := Retangulo{5.0, 3.0}\n    circulo := Circulo{2.5}\n    \n    fmt.Println(\"Ret√¢ngulo:\")\n    calcularPropriedades(retangulo)\n    \n    fmt.Println(\"\\nC√≠rculo:\")\n    calcularPropriedades(circulo)\n    \n    fmt.Println(\"\\nüîç Type Switch com interface{}:\")\n    \n    // 3. Interface{} e type switch\n    valores := []interface{}{\n        42,\n        3.14159,\n        \"Hello, World!\",\n        true,\n        pessoa,\n        gato,\n        []int{1, 2, 3},\n    }\n    \n    for i, valor := range valores {\n        fmt.Printf(\"[%d] \", i+1)\n        descreverTipo(valor)\n    }\n    \n    fmt.Println(\"\\nüîÑ Strategy Pattern:\")\n    \n    // 4. Strategy pattern com interfaces\n    texto := \"Hello World\"\n    \n    processadores := []Processador{\n        ProcessadorMaiuscula{},\n        ProcessadorMinuscula{},\n        ProcessadorInvertido{},\n    }\n    \n    for _, proc := range processadores {\n        processarTexto(proc, texto)\n    }\n    \n    fmt.Println(\"\\n‚ö†Ô∏è Type Assertion:\")\n    \n    // 5. Type assertion\n    var falador Falador = pessoa\n    \n    // Type assertion com verifica√ß√£o\n    if p, ok := falador.(Pessoa); ok {\n        fmt.Printf(\"‚úÖ √â uma pessoa: %s com %d anos\\n\", p.Nome, p.Idade)\n    }\n    \n    // Type assertion que falharia\n    if _, ok := falador.(Gato); !ok {\n        fmt.Println(\"‚ùå N√£o √© um gato\")\n    }\n    \n    fmt.Println(\"\\nüìä Interface{} em slice:\")\n    \n    // 6. Slice de interface{} - aceita qualquer tipo\n    diverso := []interface{}{\n        \"string\",\n        123,\n        45.67,\n        true,\n        Gato{\"Fluffy\"},\n    }\n    \n    for i, item := range diverso {\n        fmt.Printf(\"Item %d: %v (tipo: %T)\\n\", i+1, item, item)\n    }\n    \n    fmt.Println(\"\\nüö® Error Interface:\")\n    \n    // 7. Interface error customizada\n    resultado, err := dividirComErroCustom(10, 2)\n    if err != nil {\n        fmt.Printf(\"‚ùå %v\\n\", err)\n    } else {\n        fmt.Printf(\"‚úÖ 10 √∑ 2 = %.2f\\n\", resultado)\n    }\n    \n    resultado, err = dividirComErroCustom(10, 0)\n    if err != nil {\n        fmt.Printf(\"‚ùå %v\\n\", err)\n        \n        // Type assertion para erro customizado\n        if errCustom, ok := err.(ErroPersonalizado); ok {\n            fmt.Printf(\"   C√≥digo do erro: %d\\n\", errCustom.Codigo)\n        }\n    }\n    \n    fmt.Println(\"\\nüåü Stringer Interface:\")\n    \n    // 8. Interface Stringer (fmt.Stringer)\n    fmt.Printf(\"Pessoa com String(): %s\\n\", pessoa)\n    fmt.Printf(\"Gato sem String(): %v\\n\", gato)\n    \n    fmt.Println(\"\\n‚ú® Polimorfismo:\")\n    \n    // 9. Slice de interfaces - polimorfismo\n    faladores := []Falador{gato, cachorro, pessoa}\n    \n    fmt.Println(\"Todos falando:\")\n    for i, f := range faladores {\n        fmt.Printf(\"  %d. %s\\n\", i+1, f.Falar())\n    }\n    \n    fmt.Println(\"\\n=== RESUMO ===\\n\")\n    fmt.Println(\"‚úÖ Interfaces definem comportamentos (m√©todos)\")\n    fmt.Println(\"‚úÖ Implementa√ß√£o √© impl√≠cita - sem palavra-chave 'implements'\")\n    fmt.Println(\"‚úÖ Duck typing: \"Se tem os m√©todos, implementa a interface\"\")\n    fmt.Println(\"‚úÖ interface{} aceita qualquer tipo\")\n    fmt.Println(\"‚úÖ Type assertion extrai tipo concreto\")\n    fmt.Println(\"‚úÖ Type switch verifica m√∫ltiplos tipos\")\n    fmt.Println(\"‚úÖ Permitem polimorfismo e desacoplamento\")\n    fmt.Println(\"‚úÖ Use interfaces pequenas (1-2 m√©todos)\")\n}"
}