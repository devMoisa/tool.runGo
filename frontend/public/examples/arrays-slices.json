{
  "id": "arrays-slices",
  "title": "Arrays e Slices",
  "description": "Coleções: arrays fixos vs slices dinâmicos",
  "category": "Básicos",
  "tags": ["arrays", "slices", "coleções", "append", "make"],
  "instruction": "# Arrays e Slices em Go\n\n## Duas Formas de Coleções\n\nGo tem **duas estruturas** para listas de elementos:\n- **Arrays**: Tamanho fixo, raramente usados diretamente\n- **Slices**: Tamanho dinâmico, **mais comuns e flexíveis**\n\n## 1. Arrays - Tamanho Fixo\n\n### Declaração\n```go\nvar numeros [5]int              // Array de 5 inteiros\nvar nomes [3]string = [3]string{\"Ana\", \"João\", \"Maria\"}\n```\n\n### Características\n- ✅ **Performance**: Alocação na stack\n- ✅ **Memória**: Tamanho conhecido em tempo de compilação\n- ❌ **Inflexibilidade**: Tamanho fixo\n- ❌ **Raramente usados** em código real\n\n## 2. Slices - Tamanho Dinâmico\n\n### O que é um Slice?\nSlice é uma **\"janela\"** para um array subjacente:\n```go\nvar frutas []string  // Slice vazio\nfrutas = []string{\"maçã\", \"banana\", \"laranja\"}\n```\n\n### Anatomia de um Slice\n```\n┌─────────────┐\n│   Slice     │\n├─────────────┤\n│ Pointer   ──┼──→ [dados no array]\n│ Length: 3   │\n│ Capacity: 5 │\n└─────────────┘\n```\n\n- **Pointer**: Aponta para o primeiro elemento\n- **Length**: Quantos elementos tem (`len()`)\n- **Capacity**: Quantos elementos cabem (`cap()`)\n\n## 3. Criando Slices\n\n### Literal\n```go\nnumeros := []int{1, 2, 3, 4, 5}\n```\n\n### Com `make()`\n```go\n// make(tipo, length, capacity)\nslice1 := make([]int, 3)        // length=3, capacity=3\nslice2 := make([]int, 3, 5)     // length=3, capacity=5\n```\n\n### De um Array\n```go\narr := [5]int{1, 2, 3, 4, 5}\nslice := arr[1:4]  // [2, 3, 4] - slice do array\n```\n\n## 4. Operações com Slices\n\n### Append - Adicionar Elementos\n```go\nfrutas := []string{\"maçã\"}\nfrutas = append(frutas, \"banana\")           // [\"maçã\", \"banana\"]\nfrutas = append(frutas, \"laranja\", \"uva\")  // Múltiplos elementos\n```\n\n### Slicing - Fatiar\n```go\nnumeros := []int{0, 1, 2, 3, 4, 5}\nfmt.Println(numeros[2:5])   // [2, 3, 4]\nfmt.Println(numeros[:3])    // [0, 1, 2] - do início\nfmt.Println(numeros[3:])    // [3, 4, 5] - até o fim\n```\n\n### Copy - Copiar\n```go\noriginal := []int{1, 2, 3}\ncopia := make([]int, len(original))\ncopy(copia, original)\n```\n\n## 5. Length vs Capacity\n\n```go\nslice := make([]int, 3, 5)\nfmt.Printf(\"len=%d, cap=%d\\n\", len(slice), cap(slice))\n// Output: len=3, cap=5\n\n// Quando append excede capacity, slice é realocado\nslice = append(slice, 1, 2, 3)  // Agora cap pode ser maior\n```\n\n## 6. Zero Value\n\n```go\nvar slice []int\nfmt.Println(slice == nil)        // true\nfmt.Println(len(slice))          // 0\nfmt.Println(cap(slice))          // 0\n\n// Pode usar append mesmo sendo nil\nslice = append(slice, 1, 2, 3)   // Funciona!\n```\n\n## 7. Slices são Referencias\n\n⚠️ **Cuidado**: Slices compartilham o array subjacente\n\n```go\noriginal := []int{1, 2, 3, 4, 5}\nfatia := original[1:4]  // [2, 3, 4]\n\nfatia[0] = 99          // Modifica original também!\n// original agora é [1, 99, 3, 4, 5]\n```\n\n## Arrays vs Slices\n\n| Arrays | Slices |\n|--------|---------|\n| `[5]int` | `[]int` |\n| Tamanho fixo | Tamanho dinâmico |\n| Valor | Referência |\n| Stack | Heap (geralmente) |\n| Raramente usados | Muito comuns |\n\n## Boas Práticas\n\n✅ **Prefira slices** sobre arrays\n✅ **Use make()** quando souber o tamanho\n✅ **Pre-aloque capacity** se souber o tamanho final\n✅ **Zero value** de slice é utilizável (nil)\n⚠️ **Cuidado** com slices de slices (referências)\n⚠️ **Copy** quando precisar de dados independentes\n\n## Padrões Comuns\n\n### Filtering\n```go\nfunc filtrarPares(nums []int) []int {\n    var resultado []int\n    for _, num := range nums {\n        if num%2 == 0 {\n            resultado = append(resultado, num)\n        }\n    }\n    return resultado\n}\n```\n\n### Growing Slice\n```go\n// Eficiente: pre-aloca capacity\nslice := make([]int, 0, 1000)\nfor i := 0; i < 1000; i++ {\n    slice = append(slice, i)  // Sem realocações\n}\n```\n\n## Performance\n\n- **append()** é amortizado O(1)\n- **Realocação** acontece quando cap é excedida\n- **Pre-alocação** evita realocações desnecessárias\n\n## Experimente\n\n- Crie slices de diferentes formas\n- Teste append com diferentes capacidades\n- Veja como slicing cria \"janelas\" do mesmo array\n- Use copy para criar cópias independentes\n- Monitore len() e cap() durante operações\n\n---\n*💡 Dica: Slices são a forma idiomática de trabalhar com listas em Go!*",
  "code": "package main\n\nimport (\n    \"fmt\"\n    \"sort\"\n    \"strings\"\n)\n\nfunc main() {\n    fmt.Println(\"=== ARRAYS E SLICES ===\\n\")\n    \n    // 1. ARRAYS - Tamanho fixo\n    fmt.Println(\"📋 ARRAYS (tamanho fixo):\")\n    \n    var numeros [5]int\n    numeros[0] = 10\n    numeros[1] = 20\n    numeros[4] = 50\n    \n    fmt.Printf(\"Array: %v\\n\", numeros)\n    fmt.Printf(\"Tamanho: %d\\n\", len(numeros))\n    \n    // Array inicializado\n    frutas := [4]string{\"maçã\", \"banana\", \"laranja\", \"uva\"}\n    fmt.Printf(\"Frutas: %v\\n\", frutas)\n    \n    // Array com tamanho inferido\n    cores := [...]string{\"azul\", \"verde\", \"vermelho\"}\n    fmt.Printf(\"Cores: %v (tamanho: %d)\\n\\n\", cores, len(cores))\n    \n    // 2. SLICES - Tamanho dinâmico\n    fmt.Println(\"📝 SLICES (tamanho dinâmico):\")\n    \n    // Slice literal\n    animais := []string{\"gato\", \"cachorro\", \"pássaro\"}\n    fmt.Printf(\"Animais: %v\\n\", animais)\n    fmt.Printf(\"Length: %d, Capacity: %d\\n\", len(animais), cap(animais))\n    \n    // Slice com make()\n    idades := make([]int, 3, 5)  // length=3, capacity=5\n    idades[0] = 25\n    idades[1] = 30\n    idades[2] = 35\n    \n    fmt.Printf(\"Idades: %v\\n\", idades)\n    fmt.Printf(\"Length: %d, Capacity: %d\\n\\n\", len(idades), cap(idades))\n    \n    // 3. APPEND - Adicionando elementos\n    fmt.Println(\"➕ APPEND - Adicionando elementos:\")\n    \n    var lista []int  // slice nil\n    fmt.Printf(\"Lista inicial (nil): %v, len=%d, cap=%d\\n\", lista, len(lista), cap(lista))\n    \n    // Append funciona mesmo com slice nil\n    lista = append(lista, 1)\n    fmt.Printf(\"Após append(1): %v, len=%d, cap=%d\\n\", lista, len(lista), cap(lista))\n    \n    lista = append(lista, 2, 3, 4, 5)\n    fmt.Printf(\"Após append(2,3,4,5): %v, len=%d, cap=%d\\n\", lista, len(lista), cap(lista))\n    \n    // Append de outro slice\n    outrosNumeros := []int{6, 7, 8}\n    lista = append(lista, outrosNumeros...)  // ... desempacota o slice\n    fmt.Printf(\"Após append de outro slice: %v, len=%d, cap=%d\\n\\n\", lista, len(lista), cap(lista))\n    \n    // 4. SLICING - Fatiando slices\n    fmt.Println(\"🔪 SLICING - Fatiando:\")\n    \n    numeros2 := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n    fmt.Printf(\"Original: %v\\n\", numeros2)\n    \n    fmt.Printf(\"numeros2[2:5]: %v\\n\", numeros2[2:5])    // [2, 3, 4]\n    fmt.Printf(\"numeros2[:4]: %v\\n\", numeros2[:4])     // [0, 1, 2, 3]\n    fmt.Printf(\"numeros2[6:]: %v\\n\", numeros2[6:])     // [6, 7, 8, 9]\n    fmt.Printf(\"numeros2[:]: %v\\n\", numeros2[:])      // cópia completa\n    \n    // Cuidado: slices compartilham array subjacente\n    fatia := numeros2[2:6]  // [2, 3, 4, 5]\n    fmt.Printf(\"\\nFatia original: %v\\n\", fatia)\n    \n    fatia[0] = 99  // Modifica o array original!\n    fmt.Printf(\"Após fatia[0]=99:\\n\")\n    fmt.Printf(\"  Fatia: %v\\n\", fatia)\n    fmt.Printf(\"  Original: %v\\n\\n\", numeros2)\n    \n    // 5. COPY - Copiando slices\n    fmt.Println(\"📄 COPY - Copiando independentemente:\")\n    \n    original := []int{1, 2, 3, 4, 5}\n    copia := make([]int, len(original))\n    n := copy(copia, original)\n    \n    fmt.Printf(\"Original: %v\\n\", original)\n    fmt.Printf(\"Cópia: %v (copiados: %d elementos)\\n\", copia, n)\n    \n    // Modificando a cópia não afeta o original\n    copia[0] = 99\n    fmt.Printf(\"Após copia[0]=99:\\n\")\n    fmt.Printf(\"  Original: %v\\n\", original)\n    fmt.Printf(\"  Cópia: %v\\n\\n\", copia)\n    \n    // 6. OPERAÇÕES AVANÇADAS\n    fmt.Println(\"🚀 OPERAÇÕES AVANÇADAS:\")\n    \n    // Removendo elemento do meio\n    nums := []int{1, 2, 3, 4, 5}\n    indiceParaRemover := 2  // Remove o 3\n    \n    fmt.Printf(\"Antes da remoção: %v\\n\", nums)\n    nums = append(nums[:indiceParaRemover], nums[indiceParaRemover+1:]...)\n    fmt.Printf(\"Após remover índice 2: %v\\n\", nums)\n    \n    // Inserindo elemento\n    indiceParaInserir := 2\n    valorParaInserir := 99\n    \n    nums = append(nums[:indiceParaInserir], \n                  append([]int{valorParaInserir}, nums[indiceParaInserir:]...)...)\n    fmt.Printf(\"Após inserir 99 no índice 2: %v\\n\\n\", nums)\n    \n    // 7. SLICE DE DIFERENTES TIPOS\n    fmt.Println(\"🎨 SLICES DE DIFERENTES TIPOS:\")\n    \n    // Slice de strings\n    linguagens := []string{\"Go\", \"Python\", \"JavaScript\", \"Rust\"}\n    fmt.Printf(\"Linguagens: %v\\n\", linguagens)\n    \n    // Slice de booleans\n    flags := []bool{true, false, true, false}\n    fmt.Printf(\"Flags: %v\\n\", flags)\n    \n    // Slice de floats\n    temperaturas := []float64{36.5, 37.2, 36.8, 38.1}\n    fmt.Printf(\"Temperaturas: %v\\n\\n\", temperaturas)\n    \n    // 8. MATRIX (slice de slices)\n    fmt.Println(\"🔢 MATRIX - Slice de Slices:\")\n    \n    matrix := [][]int{\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9},\n    }\n    \n    fmt.Println(\"Matrix 3x3:\")\n    for i, linha := range matrix {\n        fmt.Printf(\"  Linha %d: %v\\n\", i, linha)\n    }\n    \n    // Acessando elemento específico\n    fmt.Printf(\"Elemento [1][2]: %d\\n\\n\", matrix[1][2])\n    \n    // 9. FUNCTIONS COM SLICES\n    fmt.Println(\"🔧 FUNÇÕES COM SLICES:\")\n    \n    valores := []int{64, 34, 25, 12, 22, 11, 90}\n    \n    fmt.Printf(\"Valores originais: %v\\n\", valores)\n    fmt.Printf(\"Soma: %d\\n\", somar(valores))\n    fmt.Printf(\"Média: %.2f\\n\", media(valores))\n    \n    pares := filtrarPares(valores)\n    fmt.Printf(\"Apenas pares: %v\\n\", pares)\n    \n    // Ordenando (modifica o slice original)\n    sort.Ints(valores)\n    fmt.Printf(\"Após ordenação: %v\\n\\n\", valores)\n    \n    // 10. PERFORMANCE E CRESCIMENTO\n    fmt.Println(\"⚡ PERFORMANCE E CRESCIMENTO:\")\n    \n    demonstrarCrescimento()\n    \n    fmt.Println(\"\\n🔍 SLICE DE STRINGS COM OPERAÇÕES:\")\n    \n    palavras := []string{\"Go\", \"é\", \"uma\", \"linguagem\", \"fantástica\"}\n    fmt.Printf(\"Palavras: %v\\n\", palavras)\n    fmt.Printf(\"Frase: %s\\n\", strings.Join(palavras, \" \"))\n    \n    // Filtrando palavras grandes\n    palavrasGrandes := filtrarPalavrasGrandes(palavras, 3)\n    fmt.Printf(\"Palavras com mais de 3 letras: %v\\n\", palavrasGrandes)\n    \n    fmt.Println(\"\\n=== RESUMO ===\\n\")\n    fmt.Println(\"✅ Arrays: tamanho fixo, [5]int\")\n    fmt.Println(\"✅ Slices: tamanho dinâmico, []int\")\n    fmt.Println(\"✅ make() cria slice com length/capacity\")\n    fmt.Println(\"✅ append() adiciona elementos\")\n    fmt.Println(\"✅ Slicing [a:b] cria \"janelas\" do array\")\n    fmt.Println(\"✅ copy() cria cópias independentes\")\n    fmt.Println(\"⚠️ Slices compartilham array subjacente\")\n    fmt.Println(\"⚡ Pre-alocar capacity melhora performance\")\n}\n\n// Função que soma elementos de um slice\nfunc somar(numeros []int) int {\n    total := 0\n    for _, num := range numeros {\n        total += num\n    }\n    return total\n}\n\n// Função que calcula média\nfunc media(numeros []int) float64 {\n    if len(numeros) == 0 {\n        return 0\n    }\n    return float64(somar(numeros)) / float64(len(numeros))\n}\n\n// Função que filtra números pares\nfunc filtrarPares(numeros []int) []int {\n    var pares []int\n    for _, num := range numeros {\n        if num%2 == 0 {\n            pares = append(pares, num)\n        }\n    }\n    return pares\n}\n\n// Função que filtra palavras grandes\nfunc filtrarPalavrasGrandes(palavras []string, tamanhoMin int) []string {\n    var resultado []string\n    for _, palavra := range palavras {\n        if len(palavra) > tamanhoMin {\n            resultado = append(resultado, palavra)\n        }\n    }\n    return resultado\n}\n\n// Demonstra como slice cresce\nfunc demonstrarCrescimento() {\n    var slice []int\n    \n    fmt.Printf(\"Crescimento do slice:\\n\")\n    for i := 0; i < 10; i++ {\n        slice = append(slice, i)\n        fmt.Printf(\"  Após append(%d): len=%d, cap=%d\\n\", i, len(slice), cap(slice))\n    }\n    \n    // Comparando com pre-alocação\n    slicePrealocado := make([]int, 0, 10)\n    fmt.Printf(\"\\nSlice pré-alocado (cap=10):\\n\")\n    for i := 0; i < 5; i++ {\n        slicePrealocado = append(slicePrealocado, i)\n        fmt.Printf(\"  Após append(%d): len=%d, cap=%d\\n\", i, len(slicePrealocado), cap(slicePrealocado))\n    }\n}"
}
