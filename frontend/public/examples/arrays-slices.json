{
  "id": "arrays-slices",
  "title": "Arrays e Slices",
  "description": "ColeÃ§Ãµes: arrays fixos vs slices dinÃ¢micos",
  "category": "BÃ¡sicos",
  "tags": ["arrays", "slices", "coleÃ§Ãµes", "append", "make"],
  "instruction": "# Arrays e Slices em Go\n\n## Duas Formas de ColeÃ§Ãµes\n\nGo tem **duas estruturas** para listas de elementos:\n- **Arrays**: Tamanho fixo, raramente usados diretamente\n- **Slices**: Tamanho dinÃ¢mico, **mais comuns e flexÃ­veis**\n\n## 1. Arrays - Tamanho Fixo\n\n### DeclaraÃ§Ã£o\n```go\nvar numeros [5]int              // Array de 5 inteiros\nvar nomes [3]string = [3]string{\"Ana\", \"JoÃ£o\", \"Maria\"}\n```\n\n### CaracterÃ­sticas\n- âœ… **Performance**: AlocaÃ§Ã£o na stack\n- âœ… **MemÃ³ria**: Tamanho conhecido em tempo de compilaÃ§Ã£o\n- âŒ **Inflexibilidade**: Tamanho fixo\n- âŒ **Raramente usados** em cÃ³digo real\n\n## 2. Slices - Tamanho DinÃ¢mico\n\n### O que Ã© um Slice?\nSlice Ã© uma **\"janela\"** para um array subjacente:\n```go\nvar frutas []string  // Slice vazio\nfrutas = []string{\"maÃ§Ã£\", \"banana\", \"laranja\"}\n```\n\n### Anatomia de um Slice\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚   Slice     â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ Pointer   â”€â”€â”¼â”€â”€â†’ [dados no array]\nâ”‚ Length: 3   â”‚\nâ”‚ Capacity: 5 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n- **Pointer**: Aponta para o primeiro elemento\n- **Length**: Quantos elementos tem (`len()`)\n- **Capacity**: Quantos elementos cabem (`cap()`)\n\n## 3. Criando Slices\n\n### Literal\n```go\nnumeros := []int{1, 2, 3, 4, 5}\n```\n\n### Com `make()`\n```go\n// make(tipo, length, capacity)\nslice1 := make([]int, 3)        // length=3, capacity=3\nslice2 := make([]int, 3, 5)     // length=3, capacity=5\n```\n\n### De um Array\n```go\narr := [5]int{1, 2, 3, 4, 5}\nslice := arr[1:4]  // [2, 3, 4] - slice do array\n```\n\n## 4. OperaÃ§Ãµes com Slices\n\n### Append - Adicionar Elementos\n```go\nfrutas := []string{\"maÃ§Ã£\"}\nfrutas = append(frutas, \"banana\")           // [\"maÃ§Ã£\", \"banana\"]\nfrutas = append(frutas, \"laranja\", \"uva\")  // MÃºltiplos elementos\n```\n\n### Slicing - Fatiar\n```go\nnumeros := []int{0, 1, 2, 3, 4, 5}\nfmt.Println(numeros[2:5])   // [2, 3, 4]\nfmt.Println(numeros[:3])    // [0, 1, 2] - do inÃ­cio\nfmt.Println(numeros[3:])    // [3, 4, 5] - atÃ© o fim\n```\n\n### Copy - Copiar\n```go\noriginal := []int{1, 2, 3}\ncopia := make([]int, len(original))\ncopy(copia, original)\n```\n\n## 5. Length vs Capacity\n\n```go\nslice := make([]int, 3, 5)\nfmt.Printf(\"len=%d, cap=%d\\n\", len(slice), cap(slice))\n// Output: len=3, cap=5\n\n// Quando append excede capacity, slice Ã© realocado\nslice = append(slice, 1, 2, 3)  // Agora cap pode ser maior\n```\n\n## 6. Zero Value\n\n```go\nvar slice []int\nfmt.Println(slice == nil)        // true\nfmt.Println(len(slice))          // 0\nfmt.Println(cap(slice))          // 0\n\n// Pode usar append mesmo sendo nil\nslice = append(slice, 1, 2, 3)   // Funciona!\n```\n\n## 7. Slices sÃ£o Referencias\n\nâš ï¸ **Cuidado**: Slices compartilham o array subjacente\n\n```go\noriginal := []int{1, 2, 3, 4, 5}\nfatia := original[1:4]  // [2, 3, 4]\n\nfatia[0] = 99          // Modifica original tambÃ©m!\n// original agora Ã© [1, 99, 3, 4, 5]\n```\n\n## Arrays vs Slices\n\n| Arrays | Slices |\n|--------|---------|\n| `[5]int` | `[]int` |\n| Tamanho fixo | Tamanho dinÃ¢mico |\n| Valor | ReferÃªncia |\n| Stack | Heap (geralmente) |\n| Raramente usados | Muito comuns |\n\n## Boas PrÃ¡ticas\n\nâœ… **Prefira slices** sobre arrays\nâœ… **Use make()** quando souber o tamanho\nâœ… **Pre-aloque capacity** se souber o tamanho final\nâœ… **Zero value** de slice Ã© utilizÃ¡vel (nil)\nâš ï¸ **Cuidado** com slices de slices (referÃªncias)\nâš ï¸ **Copy** quando precisar de dados independentes\n\n## PadrÃµes Comuns\n\n### Filtering\n```go\nfunc filtrarPares(nums []int) []int {\n    var resultado []int\n    for _, num := range nums {\n        if num%2 == 0 {\n            resultado = append(resultado, num)\n        }\n    }\n    return resultado\n}\n```\n\n### Growing Slice\n```go\n// Eficiente: pre-aloca capacity\nslice := make([]int, 0, 1000)\nfor i := 0; i < 1000; i++ {\n    slice = append(slice, i)  // Sem realocaÃ§Ãµes\n}\n```\n\n## Performance\n\n- **append()** Ã© amortizado O(1)\n- **RealocaÃ§Ã£o** acontece quando cap Ã© excedida\n- **Pre-alocaÃ§Ã£o** evita realocaÃ§Ãµes desnecessÃ¡rias\n\n## Experimente\n\n- Crie slices de diferentes formas\n- Teste append com diferentes capacidades\n- Veja como slicing cria \"janelas\" do mesmo array\n- Use copy para criar cÃ³pias independentes\n- Monitore len() e cap() durante operaÃ§Ãµes\n\n---\n*ğŸ’¡ Dica: Slices sÃ£o a forma idiomÃ¡tica de trabalhar com listas em Go!*",
  "code": "package main\n\nimport (\n    \"fmt\"\n    \"sort\"\n    \"strings\"\n)\n\nfunc main() {\n    fmt.Println(\"=== ARRAYS E SLICES ===\\n\")\n    \n    // 1. ARRAYS - Tamanho fixo\n    fmt.Println(\"ğŸ“‹ ARRAYS (tamanho fixo):\")\n    \n    var numeros [5]int\n    numeros[0] = 10\n    numeros[1] = 20\n    numeros[4] = 50\n    \n    fmt.Printf(\"Array: %v\\n\", numeros)\n    fmt.Printf(\"Tamanho: %d\\n\", len(numeros))\n    \n    // Array inicializado\n    frutas := [4]string{\"maÃ§Ã£\", \"banana\", \"laranja\", \"uva\"}\n    fmt.Printf(\"Frutas: %v\\n\", frutas)\n    \n    // Array com tamanho inferido\n    cores := [...]string{\"azul\", \"verde\", \"vermelho\"}\n    fmt.Printf(\"Cores: %v (tamanho: %d)\\n\\n\", cores, len(cores))\n    \n    // 2. SLICES - Tamanho dinÃ¢mico\n    fmt.Println(\"ğŸ“ SLICES (tamanho dinÃ¢mico):\")\n    \n    // Slice literal\n    animais := []string{\"gato\", \"cachorro\", \"pÃ¡ssaro\"}\n    fmt.Printf(\"Animais: %v\\n\", animais)\n    fmt.Printf(\"Length: %d, Capacity: %d\\n\", len(animais), cap(animais))\n    \n    // Slice com make()\n    idades := make([]int, 3, 5)  // length=3, capacity=5\n    idades[0] = 25\n    idades[1] = 30\n    idades[2] = 35\n    \n    fmt.Printf(\"Idades: %v\\n\", idades)\n    fmt.Printf(\"Length: %d, Capacity: %d\\n\\n\", len(idades), cap(idades))\n    \n    // 3. APPEND - Adicionando elementos\n    fmt.Println(\"â• APPEND - Adicionando elementos:\")\n    \n    var lista []int  // slice nil\n    fmt.Printf(\"Lista inicial (nil): %v, len=%d, cap=%d\\n\", lista, len(lista), cap(lista))\n    \n    // Append funciona mesmo com slice nil\n    lista = append(lista, 1)\n    fmt.Printf(\"ApÃ³s append(1): %v, len=%d, cap=%d\\n\", lista, len(lista), cap(lista))\n    \n    lista = append(lista, 2, 3, 4, 5)\n    fmt.Printf(\"ApÃ³s append(2,3,4,5): %v, len=%d, cap=%d\\n\", lista, len(lista), cap(lista))\n    \n    // Append de outro slice\n    outrosNumeros := []int{6, 7, 8}\n    lista = append(lista, outrosNumeros...)  // ... desempacota o slice\n    fmt.Printf(\"ApÃ³s append de outro slice: %v, len=%d, cap=%d\\n\\n\", lista, len(lista), cap(lista))\n    \n    // 4. SLICING - Fatiando slices\n    fmt.Println(\"ğŸ”ª SLICING - Fatiando:\")\n    \n    numeros2 := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n    fmt.Printf(\"Original: %v\\n\", numeros2)\n    \n    fmt.Printf(\"numeros2[2:5]: %v\\n\", numeros2[2:5])    // [2, 3, 4]\n    fmt.Printf(\"numeros2[:4]: %v\\n\", numeros2[:4])     // [0, 1, 2, 3]\n    fmt.Printf(\"numeros2[6:]: %v\\n\", numeros2[6:])     // [6, 7, 8, 9]\n    fmt.Printf(\"numeros2[:]: %v\\n\", numeros2[:])      // cÃ³pia completa\n    \n    // Cuidado: slices compartilham array subjacente\n    fatia := numeros2[2:6]  // [2, 3, 4, 5]\n    fmt.Printf(\"\\nFatia original: %v\\n\", fatia)\n    \n    fatia[0] = 99  // Modifica o array original!\n    fmt.Printf(\"ApÃ³s fatia[0]=99:\\n\")\n    fmt.Printf(\"  Fatia: %v\\n\", fatia)\n    fmt.Printf(\"  Original: %v\\n\\n\", numeros2)\n    \n    // 5. COPY - Copiando slices\n    fmt.Println(\"ğŸ“„ COPY - Copiando independentemente:\")\n    \n    original := []int{1, 2, 3, 4, 5}\n    copia := make([]int, len(original))\n    n := copy(copia, original)\n    \n    fmt.Printf(\"Original: %v\\n\", original)\n    fmt.Printf(\"CÃ³pia: %v (copiados: %d elementos)\\n\", copia, n)\n    \n    // Modificando a cÃ³pia nÃ£o afeta o original\n    copia[0] = 99\n    fmt.Printf(\"ApÃ³s copia[0]=99:\\n\")\n    fmt.Printf(\"  Original: %v\\n\", original)\n    fmt.Printf(\"  CÃ³pia: %v\\n\\n\", copia)\n    \n    // 6. OPERAÃ‡Ã•ES AVANÃ‡ADAS\n    fmt.Println(\"ğŸš€ OPERAÃ‡Ã•ES AVANÃ‡ADAS:\")\n    \n    // Removendo elemento do meio\n    nums := []int{1, 2, 3, 4, 5}\n    indiceParaRemover := 2  // Remove o 3\n    \n    fmt.Printf(\"Antes da remoÃ§Ã£o: %v\\n\", nums)\n    nums = append(nums[:indiceParaRemover], nums[indiceParaRemover+1:]...)\n    fmt.Printf(\"ApÃ³s remover Ã­ndice 2: %v\\n\", nums)\n    \n    // Inserindo elemento\n    indiceParaInserir := 2\n    valorParaInserir := 99\n    \n    nums = append(nums[:indiceParaInserir], \n                  append([]int{valorParaInserir}, nums[indiceParaInserir:]...)...)\n    fmt.Printf(\"ApÃ³s inserir 99 no Ã­ndice 2: %v\\n\\n\", nums)\n    \n    // 7. SLICE DE DIFERENTES TIPOS\n    fmt.Println(\"ğŸ¨ SLICES DE DIFERENTES TIPOS:\")\n    \n    // Slice de strings\n    linguagens := []string{\"Go\", \"Python\", \"JavaScript\", \"Rust\"}\n    fmt.Printf(\"Linguagens: %v\\n\", linguagens)\n    \n    // Slice de booleans\n    flags := []bool{true, false, true, false}\n    fmt.Printf(\"Flags: %v\\n\", flags)\n    \n    // Slice de floats\n    temperaturas := []float64{36.5, 37.2, 36.8, 38.1}\n    fmt.Printf(\"Temperaturas: %v\\n\\n\", temperaturas)\n    \n    // 8. MATRIX (slice de slices)\n    fmt.Println(\"ğŸ”¢ MATRIX - Slice de Slices:\")\n    \n    matrix := [][]int{\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9},\n    }\n    \n    fmt.Println(\"Matrix 3x3:\")\n    for i, linha := range matrix {\n        fmt.Printf(\"  Linha %d: %v\\n\", i, linha)\n    }\n    \n    // Acessando elemento especÃ­fico\n    fmt.Printf(\"Elemento [1][2]: %d\\n\\n\", matrix[1][2])\n    \n    // 9. FUNCTIONS COM SLICES\n    fmt.Println(\"ğŸ”§ FUNÃ‡Ã•ES COM SLICES:\")\n    \n    valores := []int{64, 34, 25, 12, 22, 11, 90}\n    \n    fmt.Printf(\"Valores originais: %v\\n\", valores)\n    fmt.Printf(\"Soma: %d\\n\", somar(valores))\n    fmt.Printf(\"MÃ©dia: %.2f\\n\", media(valores))\n    \n    pares := filtrarPares(valores)\n    fmt.Printf(\"Apenas pares: %v\\n\", pares)\n    \n    // Ordenando (modifica o slice original)\n    sort.Ints(valores)\n    fmt.Printf(\"ApÃ³s ordenaÃ§Ã£o: %v\\n\\n\", valores)\n    \n    // 10. PERFORMANCE E CRESCIMENTO\n    fmt.Println(\"âš¡ PERFORMANCE E CRESCIMENTO:\")\n    \n    demonstrarCrescimento()\n    \n    fmt.Println(\"\\nğŸ” SLICE DE STRINGS COM OPERAÃ‡Ã•ES:\")\n    \n    palavras := []string{\"Go\", \"Ã©\", \"uma\", \"linguagem\", \"fantÃ¡stica\"}\n    fmt.Printf(\"Palavras: %v\\n\", palavras)\n    fmt.Printf(\"Frase: %s\\n\", strings.Join(palavras, \" \"))\n    \n    // Filtrando palavras grandes\n    palavrasGrandes := filtrarPalavrasGrandes(palavras, 3)\n    fmt.Printf(\"Palavras com mais de 3 letras: %v\\n\", palavrasGrandes)\n    \n    fmt.Println(\"\\n=== RESUMO ===\\n\")\n    fmt.Println(\"âœ… Arrays: tamanho fixo, [5]int\")\n    fmt.Println(\"âœ… Slices: tamanho dinÃ¢mico, []int\")\n    fmt.Println(\"âœ… make() cria slice com length/capacity\")\n    fmt.Println(\"âœ… append() adiciona elementos\")\n    fmt.Println(\"âœ… Slicing [a:b] cria \"janelas\" do array\")\n    fmt.Println(\"âœ… copy() cria cÃ³pias independentes\")\n    fmt.Println(\"âš ï¸ Slices compartilham array subjacente\")\n    fmt.Println(\"âš¡ Pre-alocar capacity melhora performance\")\n}\n\n// FunÃ§Ã£o que soma elementos de um slice\nfunc somar(numeros []int) int {\n    total := 0\n    for _, num := range numeros {\n        total += num\n    }\n    return total\n}\n\n// FunÃ§Ã£o que calcula mÃ©dia\nfunc media(numeros []int) float64 {\n    if len(numeros) == 0 {\n        return 0\n    }\n    return float64(somar(numeros)) / float64(len(numeros))\n}\n\n// FunÃ§Ã£o que filtra nÃºmeros pares\nfunc filtrarPares(numeros []int) []int {\n    var pares []int\n    for _, num := range numeros {\n        if num%2 == 0 {\n            pares = append(pares, num)\n        }\n    }\n    return pares\n}\n\n// FunÃ§Ã£o que filtra palavras grandes\nfunc filtrarPalavrasGrandes(palavras []string, tamanhoMin int) []string {\n    var resultado []string\n    for _, palavra := range palavras {\n        if len(palavra) > tamanhoMin {\n            resultado = append(resultado, palavra)\n        }\n    }\n    return resultado\n}\n\n// Demonstra como slice cresce\nfunc demonstrarCrescimento() {\n    var slice []int\n    \n    fmt.Printf(\"Crescimento do slice:\\n\")\n    for i := 0; i < 10; i++ {\n        slice = append(slice, i)\n        fmt.Printf(\"  ApÃ³s append(%d): len=%d, cap=%d\\n\", i, len(slice), cap(slice))\n    }\n    \n    // Comparando com pre-alocaÃ§Ã£o\n    slicePrealocado := make([]int, 0, 10)\n    fmt.Printf(\"\\nSlice prÃ©-alocado (cap=10):\\n\")\n    for i := 0; i < 5; i++ {\n        slicePrealocado = append(slicePrealocado, i)\n        fmt.Printf(\"  ApÃ³s append(%d): len=%d, cap=%d\\n\", i, len(slicePrealocado), cap(slicePrealocado))\n    }\n}"
}
