{
  "id": "error-handling",
  "title": "Tratamento de Erros",
  "description": "Padr√µes idiom√°ticos de tratamento de erros em Go",
  "category": "B√°sicos",
  "tags": ["erros", "error", "panic", "recover", "tratamento"],
  "instruction": "# Tratamento de Erros em Go\n\n## Filosofia do Go: Erros s√£o Valores\n\nGo **n√£o tem exce√ß√µes**! Em vez disso, fun√ß√µes retornam um valor `error` junto com o resultado normal.\n\n## Por que essa abordagem?\n\n‚úÖ **Expl√≠cito**: Voc√™ v√™ onde erros podem ocorrer\n‚úÖ **Controle**: Voc√™ decide como lidar com cada erro\n‚úÖ **Performance**: Sem overhead de exce√ß√µes\n‚úÖ **Legibilidade**: Fluxo linear, sem try/catch\n\n## 1. O Tipo `error`\n\n`error` √© uma **interface** com um m√©todo:\n```go\ntype error interface {\n    Error() string\n}\n```\n\n- `nil` = sem erro\n- Qualquer valor n√£o-nil = erro ocorreu\n\n## 2. Padr√£o B√°sico\n\n```go\nresultado, err := funcaoQuePodeErrar()\nif err != nil {\n    // Lidar com o erro\n    return err // Propagar\n}\n// Usar resultado normalmente\n```\n\n## 3. Criando Erros\n\n### Com `errors.New()`\n```go\nif divisor == 0 {\n    return 0, errors.New(\"divis√£o por zero\")\n}\n```\n\n### Com `fmt.Errorf()` (formatado)\n```go\nif idade < 0 {\n    return fmt.Errorf(\"idade inv√°lida: %d\", idade)\n}\n```\n\n### Erros Customizados\n```go\ntype MeuErro struct {\n    Codigo int\n    Msg    string\n}\n\nfunc (e MeuErro) Error() string {\n    return fmt.Sprintf(\"erro %d: %s\", e.Codigo, e.Msg)\n}\n```\n\n## 4. Estrat√©gias de Tratamento\n\n### A) Propagar o Erro\n```go\nfunc lerConfig() error {\n    data, err := os.ReadFile(\"config.json\")\n    if err != nil {\n        return err // Passa o erro para cima\n    }\n    return nil\n}\n```\n\n### B) Adicionar Contexto\n```go\nfunc lerConfig() error {\n    data, err := os.ReadFile(\"config.json\")\n    if err != nil {\n        return fmt.Errorf(\"falha ao ler config: %w\", err)\n    }\n    return nil\n}\n```\n\n### C) Tratar e Continuar\n```go\nfunc processarItens() {\n    for _, item := range items {\n        if err := processar(item); err != nil {\n            log.Printf(\"Erro no item %v: %v\", item, err)\n            continue // Continua com pr√≥ximo item\n        }\n    }\n}\n```\n\n### D) Valor Padr√£o\n```go\nfunc obterConfigOuPadrao() int {\n    valor, err := lerConfig()\n    if err != nil {\n        return 8080 // Valor padr√£o\n    }\n    return valor\n}\n```\n\n## 5. Panic e Recover\n\n‚ö†Ô∏è **Panic** para erros **irrecuper√°veis**:\n```go\nif config == nil {\n    panic(\"configura√ß√£o √© obrigat√≥ria\")\n}\n```\n\n**Recover** para capturar panics:\n```go\nfunc segura() {\n    defer func() {\n        if r := recover(); r != nil {\n            fmt.Printf(\"Recuperado de panic: %v\", r)\n        }\n    }()\n    // ... c√≥digo que pode dar panic\n}\n```\n\n## 6. Verifica√ß√£o de Tipos de Erro\n\n```go\nif err != nil {\n    if os.IsNotExist(err) {\n        fmt.Println(\"Arquivo n√£o existe\")\n    } else if os.IsPermission(err) {\n        fmt.Println(\"Sem permiss√£o\")\n    } else {\n        fmt.Printf(\"Outro erro: %v\", err)\n    }\n}\n```\n\n## Boas Pr√°ticas\n\n‚úÖ **Sempre verifique** erros - n√£o ignore\n‚úÖ **Seja espec√≠fico** nas mensagens\n‚úÖ **Use fmt.Errorf** para adicionar contexto\n‚úÖ **Panic apenas** para erros irrecuper√°veis\n‚úÖ **Log erros** antes de propagar\n‚ùå **N√£o abuse** de panic/recover\n‚ùå **N√£o ignore** erros com `_`\n\n## Padr√£o \"Don't Panic\"\n\n- **Prefira error** sobre panic\n- **Panic** apenas para bugs de programa√ß√£o\n- **Recover** apenas em boundaries (HTTP handlers, goroutines)\n\n## Experimente\n\n- Modifique os valores para gerar diferentes tipos de erro\n- Teste cen√°rios com arquivos inexistentes\n- Veja como diferentes fun√ß√µes lidam com erros\n- Adicione seus pr√≥prios tipos de erro customizados\n\n---\n*üí° Dica: Em Go, lidar com erros explicitamente torna o c√≥digo mais robusto e previs√≠vel!*",
  "code": "package main\n\nimport (\n    \"errors\"\n    \"fmt\"\n    \"os\"\n    \"strconv\"\n    \"time\"\n)\n\n// Erro customizado\ntype IdadeInvalidaError struct {\n    Idade int\n    Min   int\n    Max   int\n}\n\nfunc (e IdadeInvalidaError) Error() string {\n    return fmt.Sprintf(\"idade %d inv√°lida: deve estar entre %d e %d\", \n        e.Idade, e.Min, e.Max)\n}\n\n// Fun√ß√£o que retorna erro simples\nfunc dividir(a, b float64) (float64, error) {\n    if b == 0 {\n        return 0, errors.New(\"n√£o √© poss√≠vel dividir por zero\")\n    }\n    return a / b, nil\n}\n\n// Fun√ß√£o com erro formatado\nfunc validarIdade(idade int) error {\n    if idade < 0 {\n        return fmt.Errorf(\"idade n√£o pode ser negativa: %d\", idade)\n    }\n    if idade > 150 {\n        return fmt.Errorf(\"idade muito alta: %d\", idade)\n    }\n    return nil\n}\n\n// Fun√ß√£o com erro customizado\nfunc criarUsuario(nome string, idade int) error {\n    if nome == \"\" {\n        return errors.New(\"nome √© obrigat√≥rio\")\n    }\n    \n    if idade < 13 || idade > 120 {\n        return IdadeInvalidaError{\n            Idade: idade,\n            Min:   13,\n            Max:   120,\n        }\n    }\n    \n    fmt.Printf(\"‚úÖ Usu√°rio criado: %s, %d anos\\n\", nome, idade)\n    return nil\n}\n\n// Fun√ß√£o que pode dar panic e usar recover\nfunc operacaoArriscada(valor int) (resultado int) {\n    defer func() {\n        if r := recover(); r != nil {\n            fmt.Printf(\"üö® Panic recuperado: %v\\n\", r)\n            resultado = -1 // Valor padr√£o em caso de panic\n        }\n    }()\n    \n    if valor == 666 {\n        panic(\"valor amaldi√ßoado!\")\n    }\n    \n    if valor == 0 {\n        // Isso causaria panic (divis√£o por zero)\n        return 100 / valor\n    }\n    \n    return valor * 2\n}\n\n// Fun√ß√£o que tenta ler arquivo e trata diferentes erros\nfunc lerArquivo(nome string) (string, error) {\n    data, err := os.ReadFile(nome)\n    if err != nil {\n        if os.IsNotExist(err) {\n            return \"\", fmt.Errorf(\"arquivo '%s' n√£o encontrado\", nome)\n        }\n        if os.IsPermission(err) {\n            return \"\", fmt.Errorf(\"sem permiss√£o para ler '%s'\", nome)\n        }\n        return \"\", fmt.Errorf(\"erro ao ler arquivo '%s': %w\", nome, err)\n    }\n    return string(data), nil\n}\n\n// Fun√ß√£o que tenta converter string para n√∫mero com fallback\nfunc converterComPadrao(str string, padrao int) int {\n    if valor, err := strconv.Atoi(str); err == nil {\n        return valor\n    }\n    fmt.Printf(\"‚ö†Ô∏è Erro ao converter '%s', usando padr√£o %d\\n\", str, padrao)\n    return padrao\n}\n\nfunc main() {\n    fmt.Println(\"=== TRATAMENTO DE ERROS ===\\n\")\n    \n    // 1. Erro b√°sico\n    fmt.Println(\"üíß Testando divis√£o:\")\n    if resultado, err := dividir(10, 2); err != nil {\n        fmt.Printf(\"‚ùå Erro: %v\\n\", err)\n    } else {\n        fmt.Printf(\"‚úÖ 10 √∑ 2 = %.2f\\n\", resultado)\n    }\n    \n    if resultado, err := dividir(10, 0); err != nil {\n        fmt.Printf(\"‚ùå Erro: %v\\n\", err)\n    } else {\n        fmt.Printf(\"‚úÖ Resultado: %.2f\\n\", resultado)\n    }\n    \n    fmt.Println(\"\\nüîç Testando valida√ß√£o:\")\n    \n    // 2. Erro formatado\n    idades := []int{25, -5, 200}\n    for _, idade := range idades {\n        if err := validarIdade(idade); err != nil {\n            fmt.Printf(\"‚ùå %v\\n\", err)\n        } else {\n            fmt.Printf(\"‚úÖ Idade %d √© v√°lida\\n\", idade)\n        }\n    }\n    \n    fmt.Println(\"\\nüë§ Testando cria√ß√£o de usu√°rios:\")\n    \n    // 3. Erro customizado\n    usuarios := []struct{ nome string; idade int }{\n        {\"Ana\", 25},\n        {\"\", 30},\n        {\"Jo√£o\", 10},\n        {\"Maria\", 250},\n    }\n    \n    for _, u := range usuarios {\n        if err := criarUsuario(u.nome, u.idade); err != nil {\n            fmt.Printf(\"‚ùå %v\\n\", err)\n            \n            // Verificando tipo espec√≠fico de erro\n            var idadeErr IdadeInvalidaError\n            if errors.As(err, &idadeErr) {\n                fmt.Printf(\"   üí° Dica: idade deve estar entre %d e %d\\n\", \n                    idadeErr.Min, idadeErr.Max)\n            }\n        }\n    }\n    \n    fmt.Println(\"\\nüé≤ Testando opera√ß√µes arriscadas:\")\n    \n    // 4. Panic e recover\n    valores := []int{5, 0, 666, 10}\n    for _, valor := range valores {\n        resultado := operacaoArriscada(valor)\n        fmt.Printf(\"Valor %d ‚Üí Resultado %d\\n\", valor, resultado)\n    }\n    \n    fmt.Println(\"\\nüìÅ Testando leitura de arquivos:\")\n    \n    // 5. Tratamento de diferentes tipos de erro de arquivo\n    arquivos := []string{\"config.json\", \"/etc/passwd\", \"inexistente.txt\"}\n    \n    for _, arquivo := range arquivos {\n        if conteudo, err := lerArquivo(arquivo); err != nil {\n            fmt.Printf(\"‚ùå %v\\n\", err)\n        } else {\n            fmt.Printf(\"‚úÖ Lido %d bytes de %s\\n\", len(conteudo), arquivo)\n        }\n    }\n    \n    fmt.Println(\"\\nüî¢ Testando convers√µes com fallback:\")\n    \n    // 6. Tratamento com valor padr√£o\n    strings := []string{\"123\", \"abc\", \"456\", \"xyz\"}\n    \n    for _, str := range strings {\n        valor := converterComPadrao(str, 0)\n        fmt.Printf(\"'%s' ‚Üí %d\\n\", str, valor)\n    }\n    \n    fmt.Println(\"\\n‚è∞ Simulando timeout:\")\n    \n    // 7. Simula√ß√£o de timeout\n    timeout := time.After(1 * time.Second)\n    done := make(chan bool)\n    \n    go func() {\n        time.Sleep(500 * time.Millisecond) // Simula trabalho\n        done <- true\n    }()\n    \n    select {\n    case <-done:\n        fmt.Println(\"‚úÖ Opera√ß√£o conclu√≠da com sucesso\")\n    case <-timeout:\n        fmt.Println(\"‚ùå Opera√ß√£o expirou (timeout)\")\n    }\n    \n    fmt.Println(\"\\n=== RESUMO ===\\n\")\n    fmt.Println(\"‚úÖ Erros s√£o valores em Go - sempre verifique!\")\n    fmt.Println(\"‚úÖ Use fmt.Errorf para adicionar contexto\")\n    fmt.Println(\"‚úÖ Crie tipos de erro customizados quando necess√°rio\")\n    fmt.Println(\"‚úÖ Panic apenas para erros irrecuper√°veis\")\n    fmt.Println(\"‚úÖ Recover para capturar panics em boundaries\")\n}"
}