{
  "id": "structs-methods",
  "title": "Structs e M√©todos",
  "description": "Definindo tipos customizados, structs e m√©todos",
  "category": "B√°sicos",
  "tags": ["structs", "m√©todos", "tipos", "receiver", "composi√ß√£o"],
  "instruction": "# Structs e M√©todos em Go\n\n## O que s√£o Structs?\n\nStructs s√£o **tipos customizados** que agrupam dados relacionados. S√£o como classes em outras linguagens, mas **sem heran√ßa**.\n\n```go\ntype Pessoa struct {\n    Nome  string\n    Idade int\n    Email string\n}\n```\n\n## Por que usar Structs?\n\n‚úÖ **Organiza√ß√£o**: Dados relacionados ficam juntos\n‚úÖ **Type Safety**: Cada struct √© um tipo √∫nico\n‚úÖ **M√©todos**: Comportamentos espec√≠ficos do tipo\n‚úÖ **Composi√ß√£o**: Combine structs para reutilizar c√≥digo\n\n## 1. Declarando Structs\n\n### Struct B√°sica\n```go\ntype Produto struct {\n    ID    int\n    Nome  string\n    Preco float64\n}\n```\n\n### Struct com Tags\n```go\ntype Usuario struct {\n    Nome  string `json:\"name\"`\n    Email string `json:\"email\"`\n    Idade int    `json:\"age\"`\n}\n```\n\n### Struct An√¥nima\n```go\nvar config = struct {\n    Host string\n    Port int\n}{\n    Host: \"localhost\",\n    Port: 8080,\n}\n```\n\n## 2. Criando Inst√¢ncias\n\n### Forma Literal\n```go\np := Pessoa{\n    Nome:  \"Ana\",\n    Idade: 25,\n    Email: \"ana@email.com\",\n}\n```\n\n### Com `new()`\n```go\np := new(Pessoa)  // Cria com zero values\np.Nome = \"Ana\"\n```\n\n### Zero Value\n```go\nvar p Pessoa  // Nome: \"\", Idade: 0, Email: \"\"\n```\n\n## 3. M√©todos\n\nM√©todos s√£o **fun√ß√µes associadas a tipos**:\n\n```go\nfunc (p Pessoa) Apresentar() string {\n    return fmt.Sprintf(\"Ol√°, sou %s\", p.Nome)\n}\n\n// Uso\nana := Pessoa{Nome: \"Ana\"}\nfmt.Println(ana.Apresentar())  // \"Ol√°, sou Ana\"\n```\n\n### Receiver por Valor vs Ponteiro\n\n**Por Valor** (c√≥pia):\n```go\nfunc (p Pessoa) ExibirIdade() {\n    fmt.Printf(\"%s tem %d anos\", p.Nome, p.Idade)\n}\n```\n\n**Por Ponteiro** (modifica original):\n```go\nfunc (p *Pessoa) FazerAniversario() {\n    p.Idade++  // Modifica o original\n}\n```\n\n## 4. Composi√ß√£o (Embedding)\n\nGo usa **composi√ß√£o** ao inv√©s de heran√ßa:\n\n```go\ntype Endereco struct {\n    Rua    string\n    Cidade string\n}\n\ntype Cliente struct {\n    Pessoa          // Embedding - Cliente \"tem\" Pessoa\n    Endereco        // Cliente \"tem\" Endereco  \n    ClienteDesde time.Time\n}\n\n// Acesso direto aos campos embedados\ncliente := Cliente{}\ncliente.Nome = \"Jo√£o\"     // Campo de Pessoa\ncliente.Rua = \"Rua A\"     // Campo de Endereco\n```\n\n## 5. M√©todos com Diferentes Receivers\n\n```go\ntype Contador struct {\n    valor int\n}\n\n// Getter (por valor)\nfunc (c Contador) Valor() int {\n    return c.valor\n}\n\n// Setter (por ponteiro)\nfunc (c *Contador) Incrementar() {\n    c.valor++\n}\n\n// Reset (por ponteiro)\nfunc (c *Contador) Reset() {\n    c.valor = 0\n}\n```\n\n## 6. Construtores (Padr√£o)\n\nGo n√£o tem construtores built-in, mas voc√™ pode criar fun√ß√µes:\n\n```go\nfunc NewPessoa(nome string, idade int) *Pessoa {\n    return &Pessoa{\n        Nome:  nome,\n        Idade: idade,\n        Email: strings.ToLower(nome) + \"@email.com\",\n    }\n}\n\n// Uso\nana := NewPessoa(\"Ana\", 25)\n```\n\n## 7. Visibility (Visibilidade)\n\n- **Mai√∫scula**: P√∫blico (exportado)\n- **Min√∫scula**: Privado (package)\n\n```go\ntype Usuario struct {\n    Nome     string  // P√∫blico\n    idade    int     // Privado\n    Email    string  // P√∫blico\n    senha    string  // Privado\n}\n```\n\n## Boas Pr√°ticas\n\n‚úÖ **Use ponteiros** para m√©todos que modificam\n‚úÖ **Use valores** para m√©todos que apenas leem\n‚úÖ **Nomes descritivos** para structs e m√©todos\n‚úÖ **Composi√ß√£o** ao inv√©s de heran√ßa\n‚úÖ **Construtores** para inicializa√ß√£o complexa\n‚úÖ **Zero values** √∫teis sempre que poss√≠vel\n‚ùå **Evite** structs muito grandes\n‚ùå **N√£o abuse** de embedding\n\n## Padr√µes Comuns\n\n### Builder Pattern\n```go\nfunc (p *Pessoa) ComNome(nome string) *Pessoa {\n    p.Nome = nome\n    return p\n}\n\nfunc (p *Pessoa) ComIdade(idade int) *Pessoa {\n    p.Idade = idade\n    return p\n}\n\n// Uso fluente\nana := new(Pessoa).ComNome(\"Ana\").ComIdade(25)\n```\n\n### String() Method\n```go\nfunc (p Pessoa) String() string {\n    return fmt.Sprintf(\"%s (%d anos)\", p.Nome, p.Idade)\n}\n\n// fmt.Println automaticamente usa String()\nfmt.Println(ana)  // \"Ana (25 anos)\"\n```\n\n## Experimente\n\n- Crie seus pr√≥prios tipos de struct\n- Adicione m√©todos com diferentes receivers\n- Teste composi√ß√£o com embedding\n- Modifique os valores e veja como ponteiros vs valores se comportam\n- Crie construtores para seus tipos\n\n---\n*üí° Dica: Structs + m√©todos + composi√ß√£o = orienta√ß√£o a objetos do Go!*",
  "code": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"time\"\n)\n\n// Struct b√°sica\ntype Pessoa struct {\n    Nome  string\n    Idade int\n    Email string\n}\n\n// M√©todo com receiver por valor (apenas l√™)\nfunc (p Pessoa) Apresentar() string {\n    return fmt.Sprintf(\"üëã Ol√°! Meu nome √© %s e tenho %d anos\", p.Nome, p.Idade)\n}\n\n// M√©todo com receiver por ponteiro (modifica)\nfunc (p *Pessoa) FazerAniversario() {\n    p.Idade++\n    fmt.Printf(\"üéâ %s fez anivers√°rio! Agora tem %d anos\\n\", p.Nome, p.Idade)\n}\n\n// M√©todo String() - implementa Stringer interface\nfunc (p Pessoa) String() string {\n    return fmt.Sprintf(\"%s (%d anos) - %s\", p.Nome, p.Idade, p.Email)\n}\n\n// Struct para composi√ß√£o\ntype Endereco struct {\n    Rua     string\n    Numero  int\n    Cidade  string\n    Estado  string\n    CEP     string\n}\n\nfunc (e Endereco) EnderecoCompleto() string {\n    return fmt.Sprintf(\"%s, %d - %s/%s - CEP: %s\", \n        e.Rua, e.Numero, e.Cidade, e.Estado, e.CEP)\n}\n\n// Struct com composi√ß√£o (embedding)\ntype Cliente struct {\n    Pessoa              // Embedding - Cliente \"herda\" campos e m√©todos de Pessoa\n    Endereco            // Embedding - Cliente \"herda\" campos e m√©todos de Endereco\n    ClienteDesde time.Time\n    Ativo        bool\n}\n\n// M√©todo espec√≠fico do Cliente\nfunc (c Cliente) TempoComoCliente() time.Duration {\n    return time.Since(c.ClienteDesde)\n}\n\nfunc (c Cliente) StatusCliente() string {\n    status := \"‚ùå Inativo\"\n    if c.Ativo {\n        status = \"‚úÖ Ativo\"\n    }\n    anos := int(c.TempoComoCliente().Hours() / 24 / 365)\n    return fmt.Sprintf(\"%s - Cliente h√° %d anos\", status, anos)\n}\n\n// Struct para demonstrar diferentes tipos de m√©todos\ntype ContadorBancario struct {\n    titular string\n    saldo   float64\n}\n\n// Construtor (padr√£o Go)\nfunc NovaConta(titular string, saldoInicial float64) *ContadorBancario {\n    return &ContadorBancario{\n        titular: titular,\n        saldo:   saldoInicial,\n    }\n}\n\n// Getter (por valor)\nfunc (c ContadorBancario) Saldo() float64 {\n    return c.saldo\n}\n\nfunc (c ContadorBancario) Titular() string {\n    return c.titular\n}\n\n// M√©todos que modificam (por ponteiro)\nfunc (c *ContadorBancario) Depositar(valor float64) error {\n    if valor <= 0 {\n        return fmt.Errorf(\"valor deve ser positivo\")\n    }\n    c.saldo += valor\n    fmt.Printf(\"üí∞ Dep√≥sito de R$ %.2f realizado. Saldo: R$ %.2f\\n\", valor, c.saldo)\n    return nil\n}\n\nfunc (c *ContadorBancario) Sacar(valor float64) error {\n    if valor <= 0 {\n        return fmt.Errorf(\"valor deve ser positivo\")\n    }\n    if valor > c.saldo {\n        return fmt.Errorf(\"saldo insuficiente. Saldo atual: R$ %.2f\", c.saldo)\n    }\n    c.saldo -= valor\n    fmt.Printf(\"üí∏ Saque de R$ %.2f realizado. Saldo: R$ %.2f\\n\", valor, c.saldo)\n    return nil\n}\n\n// String() para ContadorBancario\nfunc (c ContadorBancario) String() string {\n    return fmt.Sprintf(\"Conta de %s - Saldo: R$ %.2f\", c.titular, c.saldo)\n}\n\n// Struct com m√©todos fluentes (Builder pattern)\ntype PessoaBuilder struct {\n    pessoa *Pessoa\n}\n\nfunc NovoBuilder() *PessoaBuilder {\n    return &PessoaBuilder{pessoa: &Pessoa{}}\n}\n\nfunc (pb *PessoaBuilder) ComNome(nome string) *PessoaBuilder {\n    pb.pessoa.Nome = nome\n    return pb\n}\n\nfunc (pb *PessoaBuilder) ComIdade(idade int) *PessoaBuilder {\n    pb.pessoa.Idade = idade\n    return pb\n}\n\nfunc (pb *PessoaBuilder) ComEmail(email string) *PessoaBuilder {\n    pb.pessoa.Email = email\n    return pb\n}\n\nfunc (pb *PessoaBuilder) Build() *Pessoa {\n    // Se email n√£o foi definido, gera automaticamente\n    if pb.pessoa.Email == \"\" && pb.pessoa.Nome != \"\" {\n        pb.pessoa.Email = strings.ToLower(\n            strings.ReplaceAll(pb.pessoa.Nome, \" \", \".\")) + \"@email.com\"\n    }\n    return pb.pessoa\n}\n\n// Construtor tradicional para Pessoa\nfunc NovaPessoa(nome string, idade int) *Pessoa {\n    email := strings.ToLower(strings.ReplaceAll(nome, \" \", \".\")) + \"@email.com\"\n    return &Pessoa{\n        Nome:  nome,\n        Idade: idade,\n        Email: email,\n    }\n}\n\nfunc main() {\n    fmt.Println(\"=== STRUCTS E M√âTODOS ===\\n\")\n    \n    // 1. Cria√ß√£o b√°sica de struct\n    fmt.Println(\"üë§ Criando pessoas:\")\n    \n    // Forma literal\n    ana := Pessoa{\n        Nome:  \"Ana Silva\",\n        Idade: 28,\n        Email: \"ana@email.com\",\n    }\n    \n    fmt.Println(ana.Apresentar())\n    fmt.Printf(\"Dados: %s\\n\\n\", ana)\n    \n    // 2. Usando construtores\n    fmt.Println(\"üèóÔ∏è Usando construtores:\")\n    \n    joao := NovaPessoa(\"Jo√£o Santos\", 35)\n    fmt.Println(joao.Apresentar())\n    fmt.Printf(\"Email gerado: %s\\n\\n\", joao.Email)\n    \n    // 3. M√©todos que modificam (ponteiros)\n    fmt.Println(\"üéÇ Anivers√°rios:\")\n    \n    fmt.Printf(\"Ana antes: %d anos\\n\", ana.Idade)\n    ana.FazerAniversario()\n    fmt.Printf(\"Ana depois: %d anos\\n\\n\", ana.Idade)\n    \n    // 4. Composi√ß√£o com embedding\n    fmt.Println(\"üè¢ Cliente com composi√ß√£o:\")\n    \n    cliente := Cliente{\n        Pessoa: Pessoa{\n            Nome:  \"Maria Oliveira\",\n            Idade: 42,\n            Email: \"maria@empresa.com\",\n        },\n        Endereco: Endereco{\n            Rua:    \"Av. Paulista\",\n            Numero: 1000,\n            Cidade: \"S√£o Paulo\",\n            Estado: \"SP\",\n            CEP:    \"01310-100\",\n        },\n        ClienteDesde: time.Now().AddDate(-3, -2, -15), // 3 anos e 2 meses atr√°s\n        Ativo:        true,\n    }\n    \n    // Acessando campos diretamente (gra√ßas ao embedding)\n    fmt.Printf(\"Cliente: %s\\n\", cliente.Nome)\n    fmt.Printf(\"Endere√ßo: %s\\n\", cliente.EnderecoCompleto())\n    fmt.Printf(\"Status: %s\\n\", cliente.StatusCliente())\n    fmt.Println(cliente.Apresentar()) // M√©todo herdado de Pessoa\n    fmt.Println()\n    \n    // 5. Conta banc√°ria com m√©todos por ponteiro\n    fmt.Println(\"üè¶ Conta banc√°ria:\")\n    \n    conta := NovaConta(\"Carlos Pereira\", 1000.0)\n    fmt.Printf(\"Conta criada: %s\\n\", conta)\n    \n    // Opera√ß√µes banc√°rias\n    if err := conta.Depositar(500.50); err != nil {\n        fmt.Printf(\"‚ùå Erro: %v\\n\", err)\n    }\n    \n    if err := conta.Sacar(200.30); err != nil {\n        fmt.Printf(\"‚ùå Erro: %v\\n\", err)\n    }\n    \n    // Tentativa de saque com saldo insuficiente\n    if err := conta.Sacar(2000.0); err != nil {\n        fmt.Printf(\"‚ùå Erro: %v\\n\", err)\n    }\n    \n    fmt.Printf(\"Estado final: %s\\n\\n\", conta)\n    \n    // 6. Builder pattern\n    fmt.Println(\"üî® Builder pattern:\")\n    \n    pessoa := NovoBuilder().\n        ComNome(\"Pedro Costa\").\n        ComIdade(29).\n        Build() // Email ser√° gerado automaticamente\n    \n    fmt.Printf(\"Pessoa criada com builder: %s\\n\", pessoa)\n    fmt.Println(pessoa.Apresentar())\n    \n    // Builder com email customizado\n    pessoaCustom := NovoBuilder().\n        ComNome(\"Laura Mendes\").\n        ComIdade(31).\n        ComEmail(\"laura.mendes@custom.com\").\n        Build()\n    \n    fmt.Printf(\"\\nPessoa com email custom: %s\\n\\n\", pessoaCustom)\n    \n    // 7. Struct an√¥nima\n    fmt.Println(\"üìä Struct an√¥nima:\")\n    \n    config := struct {\n        Host     string\n        Port     int\n        Debug    bool\n        Features []string\n    }{\n        Host:     \"localhost\",\n        Port:     8080,\n        Debug:    true,\n        Features: []string{\"auth\", \"logging\", \"metrics\"},\n    }\n    \n    fmt.Printf(\"Configura√ß√£o: %+v\\n\\n\", config)\n    \n    // 8. Demonstra√ß√£o de zero values\n    fmt.Println(\"üîÑ Zero values:\")\n    \n    var pessoaVazia Pessoa\n    fmt.Printf(\"Pessoa vazia: '%s', idade: %d, email: '%s'\\n\", \n        pessoaVazia.Nome, pessoaVazia.Idade, pessoaVazia.Email)\n    \n    // Com new()\n    pessoaNew := new(Pessoa)\n    fmt.Printf(\"Com new(): '%s', idade: %d, email: '%s'\\n\\n\", \n        pessoaNew.Nome, pessoaNew.Idade, pessoaNew.Email)\n    \n    fmt.Println(\"=== RESUMO ===\\n\")\n    fmt.Println(\"‚úÖ Structs agrupam dados relacionados\")\n    fmt.Println(\"‚úÖ M√©todos com receiver por valor: apenas leitura\")\n    fmt.Println(\"‚úÖ M√©todos com receiver por ponteiro: modificam o original\")\n    fmt.Println(\"‚úÖ Composi√ß√£o com embedding substitui heran√ßa\")\n    fmt.Println(\"‚úÖ Construtores s√£o fun√ß√µes convencionais\")\n    fmt.Println(\"‚úÖ Zero values devem ser √∫teis sempre que poss√≠vel\")\n}"
}