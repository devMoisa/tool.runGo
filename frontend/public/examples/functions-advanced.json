{
  "id": "functions-advanced",
  "title": "FunÃ§Ãµes AvanÃ§adas",
  "description": "MÃºltiplos retornos, variÃ¡dicas, defer e ordem LIFO",
  "category": "BÃ¡sicos",
  "tags": ["funÃ§Ãµes", "defer", "variÃ¡dicas", "mÃºltiplos retornos", "LIFO"],
  "instruction": "# FunÃ§Ãµes AvanÃ§adas em Go\n\n## Recursos AvanÃ§ados de FunÃ§Ãµes\n\nGo oferece recursos Ãºnicos para funÃ§Ãµes que tornam o cÃ³digo mais expressivo e seguro.\n\n## 1. MÃºltiplos Retornos\n\n### Por que usar?\n- **Tratamento de erro** idiomÃ¡tico\n- **Retornar resultado + status** em uma chamada\n- **Evita exceÃ§Ãµes** - tudo Ã© explÃ­cito\n\n```go\nfunc dividir(a, b float64) (float64, error) {\n    if b == 0 {\n        return 0, errors.New(\"divisÃ£o por zero\")\n    }\n    return a / b, nil\n}\n\n// Uso\nresultado, err := dividir(10, 2)\nif err != nil {\n    // Tratar erro\n}\n```\n\n### Retornos Nomeados\n```go\nfunc calcularStats(nums []int) (media float64, max int) {\n    // media e max jÃ¡ estÃ£o declaradas\n    for _, num := range nums {\n        if num > max {\n            max = num\n        }\n    }\n    media = float64(soma) / float64(len(nums))\n    return // retorna media e max automaticamente\n}\n```\n\n## 2. FunÃ§Ãµes VariÃ¡dicas\n\n### Sintaxe: `...tipo`\n```go\nfunc somar(nums ...int) int {\n    total := 0\n    for _, num := range nums {\n        total += num\n    }\n    return total\n}\n\n// Uso\nresult1 := somar(1, 2, 3)        // 6\nresult2 := somar(1, 2, 3, 4, 5)  // 15\n\n// Com slice\nvalores := []int{1, 2, 3}\nresult3 := somar(valores...)      // Desempacota o slice\n```\n\n### Printf Ã© VariÃ¡dica!\n```go\nfmt.Printf(\"Nome: %s, Idade: %d\\n\", nome, idade)\n// Aceita qualquer quantidade de argumentos\n```\n\n## 3. Defer - ExecuÃ§Ã£o Adiada\n\n### O que Ã© Defer?\n- **Executa no final** da funÃ§Ã£o\n- **Sempre executa**, mesmo com panic\n- **Perfeito para cleanup**: fechar arquivos, unlock mutexes\n\n```go\nfunc lerArquivo(nome string) error {\n    file, err := os.Open(nome)\n    if err != nil {\n        return err\n    }\n    defer file.Close() // Sempre executa ao sair da funÃ§Ã£o\n    \n    // ... usar file ...\n    return nil\n}\n```\n\n### Ordem LIFO (Last In, First Out)\n\nDefers sÃ£o executados em **ordem reversa**:\n\n```go\nfunc exemplo() {\n    defer fmt.Println(\"1\")\n    defer fmt.Println(\"2\") \n    defer fmt.Println(\"3\")\n    fmt.Println(\"funÃ§Ã£o\")\n}\n// Output: funÃ§Ã£o, 3, 2, 1\n```\n\n### Defer com ParÃ¢metros\n\nâš ï¸ **Valores sÃ£o capturados** na hora do defer:\n\n```go\nfunc testeDefer() {\n    i := 0\n    defer fmt.Println(\"defer:\", i) // Captura i=0\n    i++\n    fmt.Println(\"normal:\", i)      // Imprime i=1\n}\n// Output: normal: 1, defer: 0\n```\n\n## 4. PadrÃµes Comuns\n\n### Cleanup com Defer\n```go\nfunc processarDados() {\n    mutex.Lock()\n    defer mutex.Unlock() // Sempre desbloqueia\n    \n    // ... processamento crÃ­tico ...\n}\n```\n\n### Tratamento de Erro\n```go\nfunc operacaoSegura() (result int, err error) {\n    defer func() {\n        if r := recover(); r != nil {\n            err = fmt.Errorf(\"panic recuperado: %v\", r)\n        }\n    }()\n    \n    // ... cÃ³digo que pode dar panic ...\n    return result, nil\n}\n```\n\n## Boas PrÃ¡ticas\n\nâœ… **Use mÃºltiplos retornos** para (valor, erro)\nâœ… **Defer para cleanup** - sempre fecha recursos\nâœ… **VariÃ¡dicas** para APIs flexÃ­veis\nâœ… **Retornos nomeados** para funÃ§Ãµes complexas\nâš ï¸ **Cuidado com defer em loops** - pode acumular\nâš ï¸ **Defer captura valores** na hora da declaraÃ§Ã£o\n\n## Experimente\n\n- Teste funÃ§Ãµes com diferentes quantidades de argumentos\n- Veja a ordem de execuÃ§Ã£o dos defers\n- Modifique valores antes/depois do defer\n- Crie suas prÃ³prias funÃ§Ãµes variÃ¡dicas\n\n---\n*ðŸ’¡ Dica: Defer Ã© seu amigo para garantir que recursos sempre sejam liberados!*",
  "code": "package main\n\nimport (\n    \"fmt\"\n    \"errors\"\n    \"os\"\n)\n\n// FunÃ§Ã£o com mÃºltiplos retornos\nfunc dividir(a, b float64) (float64, error) {\n    if b == 0 {\n        return 0, errors.New(\"nÃ£o Ã© possÃ­vel dividir por zero\")\n    }\n    return a / b, nil\n}\n\n// FunÃ§Ã£o com retornos nomeados\nfunc calcularStats(numeros []int) (media float64, maximo int, minimo int) {\n    if len(numeros) == 0 {\n        return 0, 0, 0\n    }\n    \n    soma := 0\n    maximo = numeros[0]\n    minimo = numeros[0]\n    \n    for _, num := range numeros {\n        soma += num\n        if num > maximo {\n            maximo = num\n        }\n        if num < minimo {\n            minimo = num\n        }\n    }\n    \n    media = float64(soma) / float64(len(numeros))\n    return // Retorna as variÃ¡veis nomeadas automaticamente\n}\n\n// FunÃ§Ã£o variÃ¡dica - aceita qualquer quantidade de argumentos\nfunc somar(numeros ...int) int {\n    total := 0\n    for _, num := range numeros {\n        total += num\n    }\n    return total\n}\n\n// FunÃ§Ã£o variÃ¡dica com formataÃ§Ã£o personalizada\nfunc logf(formato string, args ...interface{}) {\n    fmt.Printf(\"[LOG] \"+formato+\"\\n\", args...)\n}\n\n// DemonstraÃ§Ã£o de defer e ordem LIFO\nfunc demonstrarDefer() {\n    fmt.Println(\"=== DEMONSTRAÃ‡ÃƒO DEFER ===\\n\")\n    \n    fmt.Println(\"1. InÃ­cio da funÃ§Ã£o\")\n    \n    defer fmt.Println(\"5. Primeiro defer (executa por Ãºltimo)\")\n    defer fmt.Println(\"4. Segundo defer\")\n    defer fmt.Println(\"3. Terceiro defer (executa primeiro)\")\n    \n    fmt.Println(\"2. Meio da funÃ§Ã£o\")\n    \n    // Esta funÃ§Ã£o termina aqui, mas os defers executam em ordem LIFO\n}\n\n// Defer com captura de valores\nfunc demonstrarCapturaDefer() {\n    fmt.Println(\"\\n=== CAPTURA DE VALORES NO DEFER ===\\n\")\n    \n    contador := 0\n    \n    // Defer captura o valor atual (0)\n    defer fmt.Printf(\"Defer - contador no momento do defer: %d\\n\", contador)\n    \n    contador++\n    fmt.Printf(\"Normal - contador apÃ³s incremento: %d\\n\", contador)\n    \n    contador++\n    fmt.Printf(\"Normal - contador apÃ³s segundo incremento: %d\\n\", contador)\n    \n    // Defer com closure (captura por referÃªncia)\n    defer func() {\n        fmt.Printf(\"Defer closure - contador final: %d\\n\", contador)\n    }()\n}\n\n// SimulaÃ§Ã£o de abertura e fechamento de arquivo com defer\nfunc simularArquivo(nomeArquivo string) error {\n    fmt.Printf(\"\\nðŸ“ Abrindo arquivo: %s\\n\", nomeArquivo)\n    \n    // Simular verificaÃ§Ã£o se arquivo existe\n    if nomeArquivo == \"inexistente.txt\" {\n        return errors.New(\"arquivo nÃ£o encontrado\")\n    }\n    \n    // Defer garante que sempre \"fechamos\" o arquivo\n    defer fmt.Printf(\"ðŸ“ Fechando arquivo: %s\\n\", nomeArquivo)\n    \n    fmt.Printf(\"ðŸ“„ Processando conteÃºdo de: %s\\n\", nomeArquivo)\n    fmt.Printf(\"âœ… Processamento concluÃ­do\\n\")\n    \n    return nil\n}\n\nfunc main() {\n    fmt.Println(\"=== MÃšLTIPLOS RETORNOS ===\\n\")\n    \n    // Testando divisÃ£o normal\n    resultado, err := dividir(10, 2)\n    if err != nil {\n        fmt.Printf(\"âŒ Erro: %v\\n\", err)\n    } else {\n        fmt.Printf(\"âœ… 10 Ã· 2 = %.2f\\n\", resultado)\n    }\n    \n    // Testando divisÃ£o por zero\n    resultado, err = dividir(10, 0)\n    if err != nil {\n        fmt.Printf(\"âŒ Erro: %v\\n\", err)\n    } else {\n        fmt.Printf(\"âœ… Resultado: %.2f\\n\", resultado)\n    }\n    \n    fmt.Println(\"\\n=== RETORNOS NOMEADOS ===\\n\")\n    \n    numeros := []int{15, 3, 9, 1, 12, 8}\n    media, max, min := calcularStats(numeros)\n    \n    fmt.Printf(\"NÃºmeros: %v\\n\", numeros)\n    fmt.Printf(\"ðŸ“Š MÃ©dia: %.2f\\n\", media)\n    fmt.Printf(\"ðŸ“ˆ MÃ¡ximo: %d\\n\", max)\n    fmt.Printf(\"ðŸ“‰ MÃ­nimo: %d\\n\", min)\n    \n    fmt.Println(\"\\n=== FUNÃ‡Ã•ES VARIÃDICAS ===\\n\")\n    \n    // Testando funÃ§Ã£o variÃ¡dica\n    fmt.Printf(\"Soma de 1,2,3: %d\\n\", somar(1, 2, 3))\n    fmt.Printf(\"Soma de 1,2,3,4,5: %d\\n\", somar(1, 2, 3, 4, 5))\n    \n    // Usando slice com funÃ§Ã£o variÃ¡dica\n    valores := []int{10, 20, 30, 40}\n    fmt.Printf(\"Soma do slice %v: %d\\n\", valores, somar(valores...))\n    \n    // FunÃ§Ã£o de log variÃ¡dica\n    logf(\"UsuÃ¡rio %s logou com ID %d\", \"JoÃ£o\", 1234)\n    logf(\"Processando %d itens em %.2f segundos\", 150, 2.5)\n    \n    // DemonstraÃ§Ãµes de defer\n    demonstrarDefer()\n    demonstrarCapturaDefer()\n    \n    fmt.Println(\"\\n=== DEFER COM CLEANUP ===\\n\")\n    \n    // Simulando processamento de arquivos\n    arquivos := []string{\"dados.txt\", \"config.json\", \"inexistente.txt\", \"log.txt\"}\n    \n    for _, arquivo := range arquivos {\n        if err := simularArquivo(arquivo); err != nil {\n            fmt.Printf(\"âŒ Erro ao processar %s: %v\\n\\n\", arquivo, err)\n        } else {\n            fmt.Println()\n        }\n    }\n    \n    fmt.Println(\"=== FIM DO PROGRAMA ===\\n\")\n    \n    // Defer final - sempre executa\n    defer fmt.Println(\"ðŸ‘‹ Programa finalizado com defer!\")\n}"
}