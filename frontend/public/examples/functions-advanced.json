{
  "id": "functions-advanced",
  "title": "Funções Avançadas",
  "description": "Múltiplos retornos, variádicas, defer e ordem LIFO",
  "category": "Básicos",
  "tags": ["funções", "defer", "variádicas", "múltiplos retornos", "LIFO"],
  "instruction": "# Funções Avançadas em Go\n\n## Recursos Avançados de Funções\n\nGo oferece recursos únicos para funções que tornam o código mais expressivo e seguro.\n\n## 1. Múltiplos Retornos\n\n### Por que usar?\n- **Tratamento de erro** idiomático\n- **Retornar resultado + status** em uma chamada\n- **Evita exceções** - tudo é explícito\n\n```go\nfunc dividir(a, b float64) (float64, error) {\n    if b == 0 {\n        return 0, errors.New(\"divisão por zero\")\n    }\n    return a / b, nil\n}\n\n// Uso\nresultado, err := dividir(10, 2)\nif err != nil {\n    // Tratar erro\n}\n```\n\n### Retornos Nomeados\n```go\nfunc calcularStats(nums []int) (media float64, max int) {\n    // media e max já estão declaradas\n    for _, num := range nums {\n        if num > max {\n            max = num\n        }\n    }\n    media = float64(soma) / float64(len(nums))\n    return // retorna media e max automaticamente\n}\n```\n\n## 2. Funções Variádicas\n\n### Sintaxe: `...tipo`\n```go\nfunc somar(nums ...int) int {\n    total := 0\n    for _, num := range nums {\n        total += num\n    }\n    return total\n}\n\n// Uso\nresult1 := somar(1, 2, 3)        // 6\nresult2 := somar(1, 2, 3, 4, 5)  // 15\n\n// Com slice\nvalores := []int{1, 2, 3}\nresult3 := somar(valores...)      // Desempacota o slice\n```\n\n### Printf é Variádica!\n```go\nfmt.Printf(\"Nome: %s, Idade: %d\\n\", nome, idade)\n// Aceita qualquer quantidade de argumentos\n```\n\n## 3. Defer - Execução Adiada\n\n### O que é Defer?\n- **Executa no final** da função\n- **Sempre executa**, mesmo com panic\n- **Perfeito para cleanup**: fechar arquivos, unlock mutexes\n\n```go\nfunc lerArquivo(nome string) error {\n    file, err := os.Open(nome)\n    if err != nil {\n        return err\n    }\n    defer file.Close() // Sempre executa ao sair da função\n    \n    // ... usar file ...\n    return nil\n}\n```\n\n### Ordem LIFO (Last In, First Out)\n\nDefers são executados em **ordem reversa**:\n\n```go\nfunc exemplo() {\n    defer fmt.Println(\"1\")\n    defer fmt.Println(\"2\") \n    defer fmt.Println(\"3\")\n    fmt.Println(\"função\")\n}\n// Output: função, 3, 2, 1\n```\n\n### Defer com Parâmetros\n\n⚠️ **Valores são capturados** na hora do defer:\n\n```go\nfunc testeDefer() {\n    i := 0\n    defer fmt.Println(\"defer:\", i) // Captura i=0\n    i++\n    fmt.Println(\"normal:\", i)      // Imprime i=1\n}\n// Output: normal: 1, defer: 0\n```\n\n## 4. Padrões Comuns\n\n### Cleanup com Defer\n```go\nfunc processarDados() {\n    mutex.Lock()\n    defer mutex.Unlock() // Sempre desbloqueia\n    \n    // ... processamento crítico ...\n}\n```\n\n### Tratamento de Erro\n```go\nfunc operacaoSegura() (result int, err error) {\n    defer func() {\n        if r := recover(); r != nil {\n            err = fmt.Errorf(\"panic recuperado: %v\", r)\n        }\n    }()\n    \n    // ... código que pode dar panic ...\n    return result, nil\n}\n```\n\n## Boas Práticas\n\n✅ **Use múltiplos retornos** para (valor, erro)\n✅ **Defer para cleanup** - sempre fecha recursos\n✅ **Variádicas** para APIs flexíveis\n✅ **Retornos nomeados** para funções complexas\n⚠️ **Cuidado com defer em loops** - pode acumular\n⚠️ **Defer captura valores** na hora da declaração\n\n## Experimente\n\n- Teste funções com diferentes quantidades de argumentos\n- Veja a ordem de execução dos defers\n- Modifique valores antes/depois do defer\n- Crie suas próprias funções variádicas\n\n---\n*💡 Dica: Defer é seu amigo para garantir que recursos sempre sejam liberados!*",
  "code": "package main\n\nimport (\n    \"fmt\"\n    \"errors\"\n    \"os\"\n)\n\n// Função com múltiplos retornos\nfunc dividir(a, b float64) (float64, error) {\n    if b == 0 {\n        return 0, errors.New(\"não é possível dividir por zero\")\n    }\n    return a / b, nil\n}\n\n// Função com retornos nomeados\nfunc calcularStats(numeros []int) (media float64, maximo int, minimo int) {\n    if len(numeros) == 0 {\n        return 0, 0, 0\n    }\n    \n    soma := 0\n    maximo = numeros[0]\n    minimo = numeros[0]\n    \n    for _, num := range numeros {\n        soma += num\n        if num > maximo {\n            maximo = num\n        }\n        if num < minimo {\n            minimo = num\n        }\n    }\n    \n    media = float64(soma) / float64(len(numeros))\n    return // Retorna as variáveis nomeadas automaticamente\n}\n\n// Função variádica - aceita qualquer quantidade de argumentos\nfunc somar(numeros ...int) int {\n    total := 0\n    for _, num := range numeros {\n        total += num\n    }\n    return total\n}\n\n// Função variádica com formatação personalizada\nfunc logf(formato string, args ...interface{}) {\n    fmt.Printf(\"[LOG] \"+formato+\"\\n\", args...)\n}\n\n// Demonstração de defer e ordem LIFO\nfunc demonstrarDefer() {\n    fmt.Println(\"=== DEMONSTRAÇÃO DEFER ===\\n\")\n    \n    fmt.Println(\"1. Início da função\")\n    \n    defer fmt.Println(\"5. Primeiro defer (executa por último)\")\n    defer fmt.Println(\"4. Segundo defer\")\n    defer fmt.Println(\"3. Terceiro defer (executa primeiro)\")\n    \n    fmt.Println(\"2. Meio da função\")\n    \n    // Esta função termina aqui, mas os defers executam em ordem LIFO\n}\n\n// Defer com captura de valores\nfunc demonstrarCapturaDefer() {\n    fmt.Println(\"\\n=== CAPTURA DE VALORES NO DEFER ===\\n\")\n    \n    contador := 0\n    \n    // Defer captura o valor atual (0)\n    defer fmt.Printf(\"Defer - contador no momento do defer: %d\\n\", contador)\n    \n    contador++\n    fmt.Printf(\"Normal - contador após incremento: %d\\n\", contador)\n    \n    contador++\n    fmt.Printf(\"Normal - contador após segundo incremento: %d\\n\", contador)\n    \n    // Defer com closure (captura por referência)\n    defer func() {\n        fmt.Printf(\"Defer closure - contador final: %d\\n\", contador)\n    }()\n}\n\n// Simulação de abertura e fechamento de arquivo com defer\nfunc simularArquivo(nomeArquivo string) error {\n    fmt.Printf(\"\\n📁 Abrindo arquivo: %s\\n\", nomeArquivo)\n    \n    // Simular verificação se arquivo existe\n    if nomeArquivo == \"inexistente.txt\" {\n        return errors.New(\"arquivo não encontrado\")\n    }\n    \n    // Defer garante que sempre \"fechamos\" o arquivo\n    defer fmt.Printf(\"📁 Fechando arquivo: %s\\n\", nomeArquivo)\n    \n    fmt.Printf(\"📄 Processando conteúdo de: %s\\n\", nomeArquivo)\n    fmt.Printf(\"✅ Processamento concluído\\n\")\n    \n    return nil\n}\n\nfunc main() {\n    fmt.Println(\"=== MÚLTIPLOS RETORNOS ===\\n\")\n    \n    // Testando divisão normal\n    resultado, err := dividir(10, 2)\n    if err != nil {\n        fmt.Printf(\"❌ Erro: %v\\n\", err)\n    } else {\n        fmt.Printf(\"✅ 10 ÷ 2 = %.2f\\n\", resultado)\n    }\n    \n    // Testando divisão por zero\n    resultado, err = dividir(10, 0)\n    if err != nil {\n        fmt.Printf(\"❌ Erro: %v\\n\", err)\n    } else {\n        fmt.Printf(\"✅ Resultado: %.2f\\n\", resultado)\n    }\n    \n    fmt.Println(\"\\n=== RETORNOS NOMEADOS ===\\n\")\n    \n    numeros := []int{15, 3, 9, 1, 12, 8}\n    media, max, min := calcularStats(numeros)\n    \n    fmt.Printf(\"Números: %v\\n\", numeros)\n    fmt.Printf(\"📊 Média: %.2f\\n\", media)\n    fmt.Printf(\"📈 Máximo: %d\\n\", max)\n    fmt.Printf(\"📉 Mínimo: %d\\n\", min)\n    \n    fmt.Println(\"\\n=== FUNÇÕES VARIÁDICAS ===\\n\")\n    \n    // Testando função variádica\n    fmt.Printf(\"Soma de 1,2,3: %d\\n\", somar(1, 2, 3))\n    fmt.Printf(\"Soma de 1,2,3,4,5: %d\\n\", somar(1, 2, 3, 4, 5))\n    \n    // Usando slice com função variádica\n    valores := []int{10, 20, 30, 40}\n    fmt.Printf(\"Soma do slice %v: %d\\n\", valores, somar(valores...))\n    \n    // Função de log variádica\n    logf(\"Usuário %s logou com ID %d\", \"João\", 1234)\n    logf(\"Processando %d itens em %.2f segundos\", 150, 2.5)\n    \n    // Demonstrações de defer\n    demonstrarDefer()\n    demonstrarCapturaDefer()\n    \n    fmt.Println(\"\\n=== DEFER COM CLEANUP ===\\n\")\n    \n    // Simulando processamento de arquivos\n    arquivos := []string{\"dados.txt\", \"config.json\", \"inexistente.txt\", \"log.txt\"}\n    \n    for _, arquivo := range arquivos {\n        if err := simularArquivo(arquivo); err != nil {\n            fmt.Printf(\"❌ Erro ao processar %s: %v\\n\\n\", arquivo, err)\n        } else {\n            fmt.Println()\n        }\n    }\n    \n    fmt.Println(\"=== FIM DO PROGRAMA ===\\n\")\n    \n    // Defer final - sempre executa\n    defer fmt.Println(\"👋 Programa finalizado com defer!\")\n}"
}